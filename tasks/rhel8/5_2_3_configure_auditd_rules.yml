# Pre Audit | Get system min UID
- name: Pre Audit | Get system min UID
  shell:
    cmd: awk '/^\s*UID_MIN/{print $2}' /etc/login.defs
  changed_when: false
  register: system_min_uid

# 5.2.3 Configure auditd rules
- name: 5.2.3 Configure auditd rules
  block:
  # 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected
  #
  # Monitor scope changes for system administrators. If the system has been properly
  # configured to force system administrators to log in as themselves first and then use the
  # sudo command to execute privileged commands, it is possible to monitor changes in
  # scope. The file /etc/sudoers , or files in /etc/sudoers.d , will be written to when the
  # file(s) or related attributes have changed. The audit records will be tagged with the
  # identifier "scope".
  - name: "5.2.3.1 Ensure changes to system administration scope (sudoers) is collected"
    block:
    # 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Audit
    - name: 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Audit
      shell:
        cmd: awk '/^ *-w/ && /\/etc\/sudoers[\/]{0,1}/ && / +-p *wa/ && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      register: audit_watch_sudoers_rule_status_check
    
    # 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Audit
    - name: 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Audit
      shell:
        cmd: auditctl -l | awk '/^ *-w/ && /\/etc\/sudoers[\/]{0,1}/ && / +-p *wa/ && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | wc -l
      changed_when: false
      register: audit_watch_sudoers_running_rule_status_check
    
    # 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Audit
    - name: 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Audit
      shell:
        cmd: awk '/^ *-w/ && /\/etc\/sudoers.d[\/]{0,1}/ && / +-p *wa/ && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      register: audit_watch_sudoers_d_rule_status_check

    # 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Audit
    - name: 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Audit
      shell:
        cmd: auditctl -l | awk '/^ *-w/ && /\/etc\/sudoers.d[\/]{0,1}/ && / +-p *wa/ && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | wc -l
      changed_when: false
      register: audit_watch_sudoers_d_running_rule_status_check

    # Extract audit result
    - set_fact:
        audit_watch_sudoers_rule_check:
          name: 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected
          scored: true
          automated: true
          remediation_status: "{{ true if ((audit_watch_sudoers_rule_status_check.stdout | int ) > 0 and (audit_watch_sudoers_running_rule_status_check.stdout | int ) > 0 and (audit_watch_sudoers_d_rule_status_check.stdout | int ) > 0 and (audit_watch_sudoers_d_running_rule_status_check.stdout | int ) > 0) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_watch_sudoers_rule_check] }}"
      changed_when: false

    # 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Remediation
    - name: 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Remediation
      lineinfile:
        line: "-w /etc/sudoers -p wa -k scope"
        regexp: '^[\s]*(-w)[\s]*(\/etc\/sudoers[\/]{0,1})[\s]*(-p)[\s]*(wa)[\s]*(-k)[\s]*[!-~]*$'
        path: "/etc/audit/rules.d/00-cis-scope.rules"
        state: present
        create: true
        mode: "0600"
        owner: root
      when: not audit_only and not audit_watch_sudoers_rule_check.remediation_status and not ((audit_watch_sudoers_rule_status_check.stdout | int ) > 0)

    # 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Remediation
    - name: 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Remediation
      lineinfile:
        line: "-w /etc/sudoers.d -p wa -k scope"
        regexp: '^[\s]*(-w)[\s]*(\/etc\/sudoers.d[\/]{0,1})[\s]*(-p)[\s]*(wa)[\s]*(-k)[\s]*[!-~]*$'
        path: "/etc/audit/rules.d/00-cis-scope.rules"
        state: present
        create: true
        mode: "0600"
        owner: root
      when: not audit_only and not audit_watch_sudoers_rule_check.remediation_status and not ((audit_watch_sudoers_d_rule_status_check.stdout | int ) > 0)

     # 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Remediation
    - name: 5.2.3.1 Ensure changes to system administration scope (sudoers) is collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_watch_sudoers_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.2 Ensure actions as another user are always logged
  #
  # sudo provides users with temporary elevated privileges to perform operations, either as
  # the superuser or another user.
  - name: "5.2.3.2 Ensure actions as another user are always logged"
    block:      
    # 5.2.3.2 Ensure actions as another user are always logged | Audit
    - name: 5.2.3.2 Ensure actions as another user are always logged | Audit
      shell:
        cmd: |
          awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&(/ -C *euid!=uid/||/ -C *uid!=euid/) \
          &&/ -S *execve/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_action_as_other_user_rule_status_check
    
    # 5.2.3.2 Ensure actions as another user are always logged | Audit
    - name: 5.2.3.2 Ensure actions as another user are always logged | Audit
      shell:
        cmd: |
          auditctl -l | awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&(/ -C *euid!=uid/||/ -C *uid!=euid/) \
          &&/ -S *execve/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_action_as_other_user_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: true
      changed_when: false

    # Check if all sudo log files rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_action_as_other_user_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all sudo log files rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_action_as_other_user_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_action_as_other_user_rule_check:
          name: 5.2.3.2 Ensure actions as another user are always logged
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_action_as_other_user_rule_check] }}"
      changed_when: false
    
    # 5.2.3.2 Ensure actions as another user are always logged | Remediation
    - name: 5.2.3.2 Ensure actions as another user are always logged | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-user-emulation.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_action_as_other_user_rule_check.remediation_status

    # 5.2.3.2 Ensure actions as another user are always logged | Remediation
    - name: 5.2.3.2 Ensure actions as another user are always logged | Remediation
      shell:
        cmd: |
          rule_count=$(awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&(/ -C *euid!=uid/||/ -C *uid!=euid/) \
          &&/ -S *execve/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo "-a always,exit -F arch=b{{ item }} -C euid!=uid -F auid!=unset -S execve -k user_emulation" >> /etc/audit/rules.d/00-cis-user-emulation.rules
      loop:
      - "32"
      - "64"
      when: not audit_only and not audit_action_as_other_user_rule_check.remediation_status

     # 5.2.3.2 Ensure actions as another user are always logged | Remediation
    - name: 5.2.3.2 Ensure actions as another user are always logged | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_action_as_other_user_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.3 Ensure events that modify the sudo log file are collected
  #
  # Monitor the sudo log file. If the system has been properly configured to disable the use
  # of the su command and force all administrators to have to log in first and then use sudo
  # to execute privileged commands, then all administrator commands will be logged to
  # /var/log/sudo.log . Any time a command is executed, an audit event will be triggered
  # as the /var/log/sudo.log file will be opened for write and the executed administration
  # command will be written to the log.
  - name: "5.2.3.3 Ensure events that modify the sudo log file are collected"
    block:
    # 5.2.3.3 Ensure events that modify the sudo log file are collected | Audit
    # List all sudo log files
    - name: 5.2.3.3 Ensure events that modify the sudo log file are collected | Audit
      shell:
        cmd: grep -r logfile /etc/sudoers* | awk -F '=' '{print $2}' | sed -e 's/"//g'
      changed_when: false
      register: sudo_log_files_list
      
    # 5.2.3.3 Ensure events that modify the sudo log file are collected | Audit
    - name: 5.2.3.3 Ensure events that modify the sudo log file are collected | Audit
      shell:
        cmd: |
          SUDO_LOG_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          [ -n "${SUDO_LOG_FILE_ESCAPED}" ] && awk "/^ *-w/ \
          && /"${SUDO_LOG_FILE_ESCAPED}"/ \
          && / +-p *wa/ \
          && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop: "{{ sudo_log_files_list.stdout_lines | default([]) | list | unique}}"
      register: audit_sudo_events_rule_status_check
    
    # 5.2.3.3 Ensure events that modify the sudo log file are collected | Audit
    - name: 5.2.3.3 Ensure events that modify the sudo log file are collected | Audit
      shell:
        cmd: |
          SUDO_LOG_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          [ -n "${SUDO_LOG_FILE_ESCAPED}" ] && auditctl -l | awk "/^ *-w/ \
          && /"${SUDO_LOG_FILE_ESCAPED}"/ \
          && / +-p *wa/ \
          && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop: "{{ sudo_log_files_list.stdout_lines | default([]) | list | unique}}"
      register: audit_sudo_events_running_rule_status_check
    
    # Define remedition status
    - set_fact:
        remediation_status: "{{ true if (sudo_log_files_list.stdout | length) > 0 else false }}"
      changed_when: false

    # Check if all sudo events rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_sudo_events_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all sudo events rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_sudo_events_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_sudo_events_rule_check:
          name: 5.2.3.3 Ensure events that modify the sudo log file are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_sudo_events_rule_check] }}"
      changed_when: false
    
    # 5.2.3.3 Ensure events that modify the sudo log file are collected | Remediation
    - name: 5.2.3.3 Ensure events that modify the sudo log file are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-sudo.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_sudo_events_rule_check.remediation_status

    # 5.2.3.3 Ensure events that modify the sudo log file are collected | Remediation
    - name: 5.2.3.3 Ensure events that modify the sudo log file are collected | Remediation
      shell:
        cmd: |
          SUDO_LOG_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          rule_count=$([ -n "${SUDO_LOG_FILE_ESCAPED}" ] && awk "/^ *-w/ \
          && /"${SUDO_LOG_FILE_ESCAPED}"/ \
          && / +-p *wa/ \
          && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo "-w {{ item }} -p wa -k sudo_log_file" >> /etc/audit/rules.d/00-cis-sudo.rules
      loop: "{{ sudo_log_files_list.stdout_lines | default([]) | list | unique}}"
      when: not audit_only and not audit_sudo_events_rule_check.remediation_status

     # 5.2.3.3 Ensure events that modify the sudo log file are collected | Remediation
    - name: 5.2.3.3 Ensure events that modify the sudo log file are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_sudo_events_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.4 Ensure events that modify date and time information are collected
  #
  # Capture events where the system date and/or time has been modified. The parameters
  # in this section are set to determine if the;
  # 
  # - adjtimex      : tune kernel clock
  # - settimeofday  : set time using timeval and timezone structures
  # - stime         : using seconds since 1/1/1970
  # - clock_settime : allows for the setting of several internal clocks and timers
  #
  # system calls have been executed. Further, ensure to write an audit record to the
  # configured audit log file upon exit, tagging the records with a unique identifier such as
  # "time-change".
  - name: "5.2.3.4 Ensure events that modify date and time information are collected"
    block:      
    # 5.2.3.4 Ensure events that modify date and time information are collected | Audit
    - name: 5.2.3.4 Ensure events that modify date and time information are collected | Audit
      shell:
        cmd: |
          awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&/ -S/ \
          &&(/adjtimex/ \
          ||/settimeofday/ \
          ||/clock_settime/ ) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_adjust_time_rule_status_check

    # 5.2.3.4 Ensure events that modify date and time information are collected | Audit
    - name: 5.2.3.4 Ensure events that modify date and time information are collected | Audit
      shell:
        cmd: |
          auditctl -l | awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&/ -S/ \
          &&(/adjtimex/ \
          ||/settimeofday/ \
          ||/clock_settime/ ) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_adjust_time_running_rule_status_check
    
    # 5.2.3.4 Ensure events that modify date and time information are collected | Audit
    - name: 5.2.3.4 Ensure events that modify date and time information are collected | Audit
      shell:
        cmd: |
          awk '/^ *-w/ \
          &&/\/etc\/localtime/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      register: audit_write_time_conf_rule_status_check

    # 5.2.3.4 Ensure events that modify date and time information are collected | Audit
    - name: 5.2.3.4 Ensure events that modify date and time information are collected | Audit
      shell:
        cmd: |
          auditctl -l | awk '/^ *-w/ \
          &&/\/etc\/localtime/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | wc -l
      changed_when: false
      register: audit_write_time_conf_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: "{{ true if (audit_write_time_conf_rule_status_check.stdout | int) > 0 and (audit_write_time_conf_running_rule_status_check.stdout | int) > 0 else false  }}"
      changed_when: false

    # Check if all time ajustement rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_adjust_time_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all time ajustement rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_adjust_time_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_adjust_time_rule_check:
          name: 5.2.3.4 Ensure events that modify date and time information are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_adjust_time_rule_check] }}"
      changed_when: false
    
    # 5.2.3.4 Ensure events that modify date and time information are collected | Remediation
    - name: 5.2.3.4 Ensure events that modify date and time information are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-time-change.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_adjust_time_rule_check.remediation_status
    
    # 5.2.3.4 Ensure events that modify date and time information are collected | Remediation
    - name: 5.2.3.4 Ensure events that modify date and time information are collected | Remediation
      lineinfile:
        line: "-w /etc/localtime -p wa -k time-change"
        regexp: '^[\s]*(-w)[\s]*(\/etc\/localtime)[\s]*(-p)[\s]*(wa)[\s]*(-k)[\s]*[!-~]*$'
        path: "/etc/audit/rules.d/00-cis-time-change.rules"
        state: present
        create: true
        mode: "0600"
        owner: root
      when: not audit_only and not audit_adjust_time_rule_check.remediation_status and not ((audit_write_time_conf_rule_status_check.stdout | int ) > 0)

    # 5.2.3.4 Ensure events that modify date and time information are collected | Remediation
    - name: 5.2.3.4 Ensure events that modify date and time information are collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&/ -S/ \
          &&(/adjtimex/ \
          ||/settimeofday/ \
          ||/clock_settime/ ) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo "-a always,exit -F arch=b{{ item }} -S adjtimex,settimeofday,clock_settime -F key=time-change" >> /etc/audit/rules.d/00-cis-time-change.rules
      loop:
      - "32"
      - "64"
      when: not audit_only and not audit_adjust_time_rule_check.remediation_status

     # 5.2.3.4 Ensure events that modify date and time information are collected | Remediation
    - name: 5.2.3.4 Ensure events that modify date and time information are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_adjust_time_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.5 Ensure events that modify the system's network environment are collected
  #
  # Record changes to network environment files or system calls. The below parameters
  # monitors the following system calls, and write an audit event on system call exit:
  # 
  # - sethostname    : set the systems host name
  # - setdomainname  : set the systems domain name
  #
  # The files being monitored are:
  # 
  # - /etc/issue                        : messages displayed pre-login
  # - /etc/hosts                        : file containing host names and associated IP addresses
  # - /etc/sysconfig/network            : additional information that is valid to all network interfaces
  # - /etc/sysconfig/network-scripts/   : directory containing network interface scripts and configurations files
  - name: "5.2.3.5 Ensure events that modify the system's network environment are collected"
    block:      
    # 5.2.3.5 Ensure events that modify the system's network environment are collected | Audit
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Audit
      shell:
        cmd: |
          awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&/ -S/ \
          &&(/sethostname,setdomainname/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_network_environment_rule_status_check

    # 5.2.3.5 Ensure events that modify the system's network environment are collected | Audit
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Audit
      shell:
        cmd: |
          auditctl -l | awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&/ -S/ \
          &&(/sethostname,setdomainname/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_network_environment_running_rule_status_check
    
    # 5.2.3.5 Ensure events that modify the system's network environment are collected | Audit
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Audit
      shell:
        cmd: |
          awk '/^ *-w/ \
          &&(/{{ item }}/) \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - '\/etc\/issue[\/]{0,1}'
      - '\/etc\/issue.net[\/]{0,1}'
      - '\/etc\/hosts[\/]{0,1}'
      - '\/etc\/sysconfig\/network[\/]{0,1}'
      register: audit_network_conf_files_rule_status_check

    # 5.2.3.5 Ensure events that modify the system's network environment are collected | Audit
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Audit
      shell:
        cmd: |
          auditctl -l | awk '/^ *-w/ \
          &&(/{{ item }}/) \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | wc -l
      changed_when: false
      loop:
      - '\/etc\/issue[\/]{0,1}'
      - '\/etc\/issue.net[\/]{0,1}'
      - '\/etc\/hosts[\/]{0,1}'
      - '\/etc\/sysconfig\/network[\/]{0,1}'
      register: audit_network_conf_files_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: true
      changed_when: false

    # Check if all network environment rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_network_environment_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all network environment rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_network_environment_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Check if all network configuration files rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_network_conf_files_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all network configuration files rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_network_conf_files_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_network_rule_check:
          name: 5.2.3.5 Ensure events that modify the system's network environment are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_network_rule_check] }}"
      changed_when: false
    
    # 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-system-local.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_network_rule_check.remediation_status

    # 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b({{ item }})/ \
          &&/ -S/ \
          &&(/sethostname,setdomainname/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo "-a always,exit -F arch=b{{ item }} -S sethostname,setdomainname -k system-locale" >> /etc/audit/rules.d/00-cis-system-local.rules
      loop:
      - "32"
      - "64"
      when: not audit_only and not audit_network_rule_check.remediation_status
    
    # 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk '/^ *-w/ \
          &&(/{{ item }}/) \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo "-w {{ item }} -p wa -k system-locale" >> /etc/audit/rules.d/00-cis-system-local.rules
      loop:
      - '/etc/issue'
      - '/etc/issue.net'
      - '/etc/hosts'
      - '/etc/sysconfig/network'
      when: not audit_only and not audit_network_rule_check.remediation_status

     # 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_network_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.6 Ensure use of privileged commands are collected
  #
  # Monitor privileged programs, those that have the setuid and/or setgid bit set on
  # execution, to determine if unprivileged users are running these commands.
  - name: "5.2.3.6 Ensure use of privileged commands are collected"
    block:
    # 5.2.3.6 Ensure use of privileged commands are collected | Audit
    - name: 5.2.3.6 Ensure use of privileged commands are collected | Audit
      shell:
        cmd: |
          for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid" | awk '{print $1}'); do
              for PRIVILEGED in $(find "$PARTITION" -xdev -perm /6000 -type f); do
                  echo "$PRIVILEGED"
              done
          done
      changed_when: false
      register: privileged_files_list
    
    # 5.2.3.6 Ensure use of privileged commands are collected | Audit
    - name: 5.2.3.6 Ensure use of privileged commands are collected | Audit
      shell:
        cmd: |
          PRIVILEGED_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          awk "/^ *-a *always,exit/ \
          &&/ -F *path=${PRIVILEGED_FILE_ESCAPED}/ \
          &&/ -F *perm=x/ \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop: "{{ privileged_files_list.stdout_lines | default([]) | list | unique }}"
      register: audit_privileged_files_rule_status_check

    # 5.2.3.6 Ensure use of privileged commands are collected | Audit
    - name: 5.2.3.6 Ensure use of privileged commands are collected | Audit
      shell:
        cmd: |
          PRIVILEGED_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          auditctl -l | awk "/^ *-a *always,exit/ \
          &&/ -F *path="${PRIVILEGED_FILE_ESCAPED}"/ \
          &&/ -F *perm=x/ \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop: "{{ privileged_files_list.stdout_lines | default([]) | list | unique }}"
      register: audit_privileged_files_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: "{{ true if system_min_uid.stdout != '' else false }}"
      changed_when: false

    # Check if all privileged files rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_privileged_files_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all privileged files rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_privileged_files_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_privileged_files_rule_check:
          name: 5.2.3.6 Ensure use of privileged commands are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_privileged_files_rule_check] }}"
      changed_when: false
    
    # 5.2.3.6 Ensure use of privileged commands are collected | Remediation
    - name: 5.2.3.6 Ensure use of privileged commands are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-privileged.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_privileged_files_rule_check.remediation_status
    
    # 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
      shell:
        cmd: |
          PRIVILEGED_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          rule_count=$(awk "/^ *-a *always,exit/ \
          &&/ -F *path="${PRIVILEGED_FILE_ESCAPED}"/ \
          &&/ -F *perm=x/ \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F path={{ item }} -F perm=x -F auid>={{ system_min_uid.stdout }} -F auid!=unset -k privileged' >> /etc/audit/rules.d/00-cis-privileged.rules
      loop: "{{ privileged_files_list.stdout_lines | default([]) | list | unique }}"
      when: not audit_only and system_min_uid.stdout != '' and not audit_privileged_files_rule_check.remediation_status

     # 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
    - name: 5.2.3.5 Ensure events that modify the system's network environment are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_privileged_files_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.7 Ensure unsuccessful file access attempts are collected
  #
  # Monitor for unsuccessful attempts to access files. The following parameters are
  # associated with system calls that control files
  #
  # - creation  : creat
  # - opening   : open , openat
  # - truncation: truncate , ftruncate
  #
  # An audit log record will only be written if all of the following criteria is met for the user
  # when trying to access a file:
  # 
  # - a non-privileged user (auid>=UID_MIN)
  # - is not a Daemon event (auid=4294967295/unset/-1)
  # - if the system call returned EACCES (permission denied) or EPERM (some other
  # - permanent error associated with the specific system call)
  - name: "5.2.3.7 Ensure unsuccessful file access attempts are collected"
    block:    
    # 5.2.3.7 Ensure unsuccessful file access attempts are collected | Audit
    - name: 5.2.3.7 Ensure unsuccessful file access attempts are collected | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *exit={{ item.access_failure }}/ \
          &&/ -S/ \
          &&/creat/ \
          &&/open/ \
          &&/truncate/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - arch: 32
        access_failure: "-EACCES"
      - arch: 64
        access_failure: "-EACCES"
      - arch: 32
        access_failure: "-EPERM"
      - arch: 64
        access_failure: "-EPERM"
      register: audit_unsuccessful_files_rule_status_check

    # 5.2.3.7 Ensure unsuccessful file access attempts are collected | Audit
    - name: 5.2.3.7 Ensure unsuccessful file access attempts are collected | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *exit={{ item.access_failure }}/ \
          &&/ -S/ \
          &&/creat/ \
          &&/open/ \
          &&/truncate/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop:
      - arch: 32
        access_failure: "-EACCES"
      - arch: 64
        access_failure: "-EACCES"
      - arch: 32
        access_failure: "-EPERM"
      - arch: 64
        access_failure: "-EPERM"
      register: audit_unsuccessful_files_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: "{{ true if system_min_uid.stdout != '' else false }}"
      changed_when: false

    # Check if all unsuccessful file access attempts rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_unsuccessful_files_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all unsuccessful file access attempts rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_unsuccessful_files_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_unsuccessful_files_rule_check:
          name: 5.2.3.7 Ensure unsuccessful file access attempts are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_unsuccessful_files_rule_check] }}"
      changed_when: false
    
    # 5.2.3.7 Ensure unsuccessful file access attempts are collected | Remediation
    - name: 5.2.3.7 Ensure unsuccessful file access attempts are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-unsuccessful-file-access.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_unsuccessful_files_rule_check.remediation_status
    
    # 5.2.3.7 Ensure unsuccessful file access attempts are collected | Remediation
    - name: 5.2.3.7 Ensure unsuccessful file access attempts are collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *exit={{ item.access_failure }}/ \
          &&/ -S/ \
          &&/creat/ \
          &&/open/ \
          &&/truncate/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F arch=b{{ item.arch }} -S creat,open,openat,truncate,ftruncate -F exit={{ item.access_failure }} -F auid>={{ system_min_uid.stdout }} -F auid!=unset -k access' >> /etc/audit/rules.d/00-cis-unsuccessful-file-access.rules
      loop:
      - arch: 32
        access_failure: "-EACCES"
      - arch: 64
        access_failure: "-EACCES"
      - arch: 32
        access_failure: "-EPERM"
      - arch: 64
        access_failure: "-EPERM"
      when: not audit_only and not audit_unsuccessful_files_rule_check.remediation_status

     # 5.2.3.7 Ensure unsuccessful file access attempts are collected | Remediation
    - name: 5.2.3.7 Ensure unsuccessful file access attempts are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_unsuccessful_files_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.8 Ensure events that modify user/group information are collected
  #
  # Record events affecting the modification of user or group information, including that of
  # passwords and old passwords if in use.
  #
  # - /etc/group            : system groups
  # - /etc/passwd           : system users
  # - /etc/gshadow          : encrypted password for each group
  # - /etc/shadow           : system user passwords
  # - /etc/security/opasswd : storage of old passwords if the relevant PAM module is in use
  #
  # The parameters in this section will watch the files to see if they have been opened for
  # write or have had attribute changes (e.g. permissions) and tag them with the identifier
  # "identity" in the audit log file.
  - name: "5.2.3.8 Ensure events that modify user/group information are collected"
    block:    
    # 5.2.3.8 Ensure events that modify user/group information are collected | Audit
    - name: 5.2.3.8 Ensure events that modify user/group information are collected | Audit
      shell:
        cmd: |
          USER_GROUP_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          awk "/^ *-w/ \
          &&/"${USER_GROUP_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "/etc/group"
      - "/etc/passwd"
      - "/etc/gshadow"
      - "/etc/shadow"
      - "/etc/security/opasswd"
      register: audit_user_group_files_rule_status_check

    # 5.2.3.8 Ensure events that modify user/group information are collected | Audit
    - name: 5.2.3.8 Ensure events that modify user/group information are collected | Audit
      shell:
        cmd: |
          USER_GROUP_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          auditctl -l | awk "/^ *-w/ \
          &&/"${USER_GROUP_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop:
      - "/etc/group"
      - "/etc/passwd"
      - "/etc/gshadow"
      - "/etc/shadow"
      - "/etc/security/opasswd"
      register: audit_user_group_files_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: true
      changed_when: false

    # Check if all user/group files rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_user_group_files_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all user/group files rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_user_group_files_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_user_group_files_rule_check:
          name: 5.2.3.8 Ensure events that modify user/group information are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_user_group_files_rule_check] }}"
      changed_when: false
    
    # 5.2.3.8 Ensure events that modify user/group information are collected | Remediation
    - name: 5.2.3.8 Ensure events that modify user/group information are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-identity.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_user_group_files_rule_check.remediation_status
    
    # 5.2.3.8 Ensure events that modify user/group information are collected | Remediation
    - name: 5.2.3.8 Ensure events that modify user/group information are collected | Remediation
      shell:
        cmd: |
          USER_GROUP_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          rule_count=$(awk "/^ *-w/ \
          &&/"${USER_GROUP_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-w {{ item }} -p wa -k identity' >> /etc/audit/rules.d/00-cis-identity.rules
      loop:
      - "/etc/group"
      - "/etc/passwd"
      - "/etc/gshadow"
      - "/etc/shadow"
      - "/etc/security/opasswd"
      when: not audit_only and not audit_user_group_files_rule_check.remediation_status

     # 5.2.3.8 Ensure events that modify user/group information are collected | Remediation
    - name: 5.2.3.8 Ensure events that modify user/group information are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_user_group_files_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.9 Ensure discretionary access control permission modification events are collected
  #
  # Monitor changes to file permissions, attributes, ownership and group. The parameters in
  # this section track changes for system calls that affect file permissions and attributes.
  # The following commands and system calls effect the permissions, ownership and
  # various attributes of files.
  #
  # - chmod
  # - fchmod
  # - fchmodat
  # - chown
  # - fchown
  # - fchownat
  # - lchown
  # - setxattr
  # - lsetxattr
  # - fsetxattr
  # - removexattr
  # - lremovexattr
  # - fremovexattr
  # 
  # In all cases, an audit record will only be written for non-system user ids and will ignore
  # Daemon events. All audit records will be tagged with the identifier "perm_mod."
  - name: "5.2.3.9 Ensure discretionary access control permission modification events are collected"
    block:    
    # 5.2.3.9 Ensure discretionary access control permission modification events are collected | Audit
    - name: 5.2.3.9 Ensure discretionary access control permission modification events are collected | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -S/ \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/{{ item.syscall }}/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - arch: 32
        syscall: "chmod,fchmod,fchmodat"
      - arch: 32
        syscall: "lchown,fchown,chown,fchownat"
      - arch: 32
        syscall: "setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr"
      - arch: 64
        syscall: "chmod,fchmod,fchmodat"
      - arch: 64
        syscall: "chown,fchown,lchown,fchownat"
      - arch: 64
        syscall: "setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr"
      register: audit_access_control_permission_rule_status_check

    # 5.2.3.9 Ensure discretionary access control permission modification events are collected | Audit
    - name: 5.2.3.9 Ensure discretionary access control permission modification events are collected | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -S/ \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/{{ item.syscall }}/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop:
      - arch: 32
        syscall: "chmod,fchmod,fchmodat"
      - arch: 32
        syscall: "lchown,fchown,chown,fchownat"
      - arch: 32
        syscall: "setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr"
      - arch: 64
        syscall: "chmod,fchmod,fchmodat"
      - arch: 64
        syscall: "chown,fchown,lchown,fchownat"
      - arch: 64
        syscall: "setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr"
      register: audit_access_control_permission_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: "{{ true if system_min_uid.stdout != '' else false }}"
      changed_when: false

    # Check if all discretionary access control permission modification events rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_access_control_permission_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all discretionary access control permission modification events files rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_access_control_permission_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_access_control_permission_rule_check:
          name: 5.2.3.9 Ensure discretionary access control permission modification events are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_access_control_permission_rule_check] }}"
      changed_when: false
    
    # 5.2.3.9 Ensure discretionary access control permission modification events are collected | Remediation
    - name: 5.2.3.9 Ensure discretionary access control permission modification events are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-perm-mod.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_access_control_permission_rule_check.remediation_status
    
    # 5.2.3.9 Ensure discretionary access control permission modification events are collected | Remediation
    - name: 5.2.3.9 Ensure discretionary access control permission modification events are collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -S/ \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/{{ item.syscall }}/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F arch=b{{ item.arch }} -S {{ item.syscall }} -F auid>={{ system_min_uid.stdout }} -F auid!=unset -F key=perm_mod' >> /etc/audit/rules.d/00-cis-perm-mod.rules
      loop:
      - arch: 32
        syscall: "chmod,fchmod,fchmodat"
      - arch: 32
        syscall: "lchown,fchown,chown,fchownat"
      - arch: 32
        syscall: "setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr"
      - arch: 64
        syscall: "chmod,fchmod,fchmodat"
      - arch: 64
        syscall: "chown,fchown,lchown,fchownat"
      - arch: 64
        syscall: "setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr"
      when: not audit_only and not audit_access_control_permission_rule_check.remediation_status

     # 5.2.3.9 Ensure discretionary access control permission modification events are collected | Remediation
    - name: 5.2.3.9 Ensure discretionary access control permission modification events are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_access_control_permission_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.10 Ensure successful file system mounts are collected
  #
  # Monitor the use of the mount system call. The mount (and umount ) system call controls
  # the mounting and unmounting of file systems. The parameters below configure the
  # system to create an audit record when the mount system call is used by a non-
  # privileged user
  - name: "5.2.3.10 Ensure successful file system mounts are collected"
    block:    
    # 5.2.3.10 Ensure successful file system mounts are collected | Audit
    - name: 5.2.3.10 Ensure successful file system mounts are collected | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&/mount/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_mount_success_rule_status_check

    # 5.2.3.10 Ensure successful file system mounts are collected | Audit
    - name: 5.2.3.10 Ensure successful file system mounts are collected | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&/mount/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_mount_success_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: "{{ true if system_min_uid.stdout != '' else false }}"
      changed_when: false

    # Check if all successful file system mounts rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_mount_success_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all successful file system mounts rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_mount_success_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_mount_success_rule_check:
          name: 5.2.3.10 Ensure successful file system mounts are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_mount_success_rule_check] }}"
      changed_when: false
    
    # 5.2.3.10 Ensure successful file system mounts are collected | Remediation
    - name: 5.2.3.10 Ensure successful file system mounts are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-mounts.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_mount_success_rule_check.remediation_status
    
    # 5.2.3.10 Ensure successful file system mounts are collected | Remediation
    - name: 5.2.3.10 Ensure successful file system mounts are collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&/mount/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F arch=b{{ item }} -S mount -F auid>={{ system_min_uid.stdout }} -F auid!=unset -k mounts' >> /etc/audit/rules.d/00-cis-mounts.rules
      loop:
      - "32"
      - "64"
      when: not audit_only and not audit_mount_success_rule_check.remediation_status

     # 5.2.3.10 Ensure successful file system mounts are collected | Remediation
    - name: 5.2.3.10 Ensure successful file system mounts are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_mount_success_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.11 Ensure session initiation information is collected
  #
  # Monitor session initiation events. The parameters in this section track changes to the
  # files associated with session events.
  #
  # - /var/run/utmp : tracks all currently logged in users.
  # - /var/log/wtmp : file tracks logins, logouts, shutdown, and reboot events.
  # - /var/log/btmp : keeps track of failed login attempts and can be read by entering
  #                   the command /usr/bin/last -f /var/log/btmp .
  #
  # All audit records will be tagged with the identifier "session."
  - name: "5.2.3.11 Ensure session initiation information is collected"
    block:    
    # 5.2.3.11 Ensure session initiation information is collected | Audit
    - name: 5.2.3.11 Ensure session initiation information is collected | Audit
      shell:
        cmd: |
          SESSION_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          awk "/^ *-w/ \
          &&/"${SESSION_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "/var/run/utmp"
      - "/var/log/wtmp"
      - "/var/log/btmp"
      register: audit_session_initiation_rule_status_check

    # 5.2.3.11 Ensure session initiation information is collected | Audit
    - name: 5.2.3.11 Ensure session initiation information is collected | Audit
      shell:
        cmd: |
          SESSION_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          auditctl -l | awk "/^ *-w/ \
          &&/"${SESSION_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop:
      - "/var/run/utmp"
      - "/var/log/wtmp"
      - "/var/log/btmp"
      register: audit_session_initiation_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: true
      changed_when: false

    # Check if all session initiation information rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_session_initiation_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all session initiation information rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_session_initiation_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_session_initiation_rule_check:
          name: 5.2.3.11 Ensure session initiation information is collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_session_initiation_rule_check] }}"
      changed_when: false
    
    # 5.2.3.11 Ensure session initiation information is collected | Remediation
    - name: 5.2.3.11 Ensure session initiation information is collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-session.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_session_initiation_rule_check.remediation_status
    
    # 5.2.3.11 Ensure session initiation information is collected | Remediation
    - name: 5.2.3.11 Ensure session initiation information is collected | Remediation
      shell:
        cmd: |
          SESSION_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          rule_count=$(awk "/^ *-w/ \
          &&/"${SESSION_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-w {{ item }} -p wa -k session' >> /etc/audit/rules.d/00-cis-session.rules
      loop:
      - "/var/run/utmp"
      - "/var/log/wtmp"
      - "/var/log/btmp"
      when: not audit_only and not audit_session_initiation_rule_check.remediation_status

     # 5.2.3.11 Ensure session initiation information is collected | Remediation
    - name: 5.2.3.11 Ensure session initiation information is collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_session_initiation_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.12 Ensure login and logout events are collected
  #
  # Monitor login and logout events. The parameters below track changes to files
  # associated with login/logout events.
  #
  # - /var/log/lastlog : maintain records of the last time a user successfully loggedin.
  # - var/run/faillock : directory maintains records of login failures via the pam_faillock module.
  - name: "5.2.3.12 Ensure login and logout events are collected"
    block:    
    # 5.2.3.12 Ensure login and logout events are collected | Audit
    - name: 5.2.3.12 Ensure login and logout events are collected | Audit
      shell:
        cmd: |
          LOGIN_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          awk "/^ *-w/ \
          &&/"${LOGIN_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "/var/log/lastlog"
      - "/var/run/faillock"
      register: audit_login_rule_status_check

    # 5.2.3.12 Ensure login and logout events are collected | Audit
    - name: 5.2.3.12 Ensure login and logout events are collected | Audit
      shell:
        cmd: |
          LOGIN_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          auditctl -l | awk "/^ *-w/ \
          &&/"${LOGIN_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop:
      - "/var/log/lastlog"
      - "/var/run/faillock"
      register: audit_login_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: true
      changed_when: false

    # Check if all login and logout events rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_login_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all login and logout events rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_login_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_login_rule_check:
          name: 5.2.3.12 Ensure login and logout events are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_login_rule_check] }}"
      changed_when: false
    
    # 5.2.3.12 Ensure login and logout events are collected | Remediation
    - name: 5.2.3.12 Ensure login and logout events are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-login.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_login_rule_check.remediation_status
    
    # 5.2.3.12 Ensure login and logout events are collected | Remediation
    - name: 5.2.3.12 Ensure login and logout events are collected | Remediation
      shell:
        cmd: |
          LOGIN_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          rule_count=$(awk "/^ *-w/ \
          &&/"${LOGIN_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-w {{ item }} -p wa -k logins' >> /etc/audit/rules.d/00-cis-login.rules
      loop:
      - "/var/log/lastlog"
      - "/var/run/faillock"
      when: not audit_only and not audit_login_rule_check.remediation_status

     # 5.2.3.12 Ensure login and logout events are collected | Remediation
    - name: 5.2.3.12 Ensure login and logout events are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_login_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.13 Ensure file deletion events by users are collected
  #
  # Monitor the use of system calls associated with the deletion or renaming of files and file
  # attributes. This configuration statement sets up monitoring for:
  #
  # - unlink    : remove a file
  # - unlinkat  : remove a file attribute
  # - fchmodat  : rename a file
  # - rename    : rename a file attribute system calls and tags them with the identifier "delete".
  - name: "5.2.3.13 Ensure file deletion events by users are collected"
    block:    
    # 5.2.3.13 Ensure file deletion events by users are collected | Audit
    - name: 5.2.3.13 Ensure file deletion events by users are collected | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&/{{ item.syscall }}/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - arch: "32"
        syscall: "unlink,rename,unlinkat,renameat"
      - arch: "64"
        syscall: "rename,unlink,unlinkat,renameat"
      register: audit_delete_file_rule_status_check

    # 5.2.3.13 Ensure file deletion events by users are collected | Audit
    - name: 5.2.3.13 Ensure file deletion events by users are collected | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&/{{ item.syscall }}/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop:
      - arch: "32"
        syscall: "unlink,rename,unlinkat,renameat"
      - arch: "64"
        syscall: "rename,unlink,unlinkat,renameat"
      register: audit_delete_file_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: "{{ true if system_min_uid.stdout != '' else false }}"
      changed_when: false

    # Check if all file deletion events rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_delete_file_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all file deletion events rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_delete_file_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_delete_file_rule_check:
          name: 5.2.3.13 Ensure file deletion events by users are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_delete_file_rule_check] }}"
      changed_when: false
    
    # 5.2.3.13 Ensure file deletion events by users are collected | Remediation
    - name: 5.2.3.13 Ensure file deletion events by users are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-delete.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_delete_file_rule_check.remediation_status
    
    # 5.2.3.13 Ensure file deletion events by users are collected | Remediation
    - name: 5.2.3.13 Ensure file deletion events by users are collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item.arch }}/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&/{{ item.syscall }}/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F arch=b{{ item.arch }} -S {{ item.syscall }} -F auid>={{ system_min_uid.stdout }} -F auid!=-1 -F key=delete' >> /etc/audit/rules.d/00-cis-delete.rules
      loop:
      - arch: "32"
        syscall: "unlink,rename,unlinkat,renameat"
      - arch: "64"
        syscall: "rename,unlink,unlinkat,renameat"
      when: not audit_only and not audit_delete_file_rule_check.remediation_status

     # 5.2.3.13 Ensure file deletion events by users are collected | Remediation
    - name: 5.2.3.13 Ensure file deletion events by users are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_delete_file_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected
  #
  # Monitor SELinux, an implementation of mandatory access controls. The parameters
  # below monitor any write access (potential additional, deletion or modification of files in
  # the directory) or attribute changes to the /etc/selinux/ and /usr/share/selinux/
  # directories.
  # Note: If a different Mandatory Access Control method is used, changes to the
  # corresponding directories should be audited.
  - name: "5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected"
    block:    
    # 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Audit
    - name: 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Audit
      shell:
        cmd: |
          MAC_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          awk "/^ *-w/ \
          &&/"${MAC_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "/etc/selinux"
      - "/usr/share/selinux"
      register: audit_mac_rule_status_check

    # 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Audit
    - name: 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Audit
      shell:
        cmd: |
          MAC_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          auditctl -l | awk "/^ *-w/ \
          &&/"${MAC_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      loop:
      - "/etc/selinux"
      - "/usr/share/selinux"
      register: audit_mac_running_rule_status_check

    # Define remediation status
    - set_fact:
        remediation_status: true
      changed_when: false

    # Check if all system's Mandatory Access modification rules are configured
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_mac_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all system's Mandatory Access modification rules are loaded
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_mac_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_mac_rule_check:
          name: 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_mac_rule_check] }}"
      changed_when: false
    
    # 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Remediation
    - name: 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-MAC-policy.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_mac_rule_check.remediation_status
    
    # 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Remediation
    - name: 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Remediation
      shell:
        cmd: |
          MAC_FILE_ESCAPED="$(echo '{{ item }}' | sed -e 's|/|\\/|g')[\/]{0,1}" # Configure the path (item) to be a valid regex

          rule_count=$(awk "/^ *-w/ \
          &&/"${MAC_FILE_ESCAPED}"/ \
          &&/ +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-w {{ item }} -p wa -k MAC-policy' >> /etc/audit/rules.d/00-cis-MAC-policy.rules
      loop:
      - "/etc/selinux"
      - "/usr/share/selinux"
      when: not audit_only and not audit_mac_rule_check.remediation_status

     # 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Remediation
    - name: 5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_mac_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded
  #
  # The operating system must generate audit records for successful/unsuccessful uses of
  # the chcon command.
  - name: "5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded"
    block:    
    # 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Audit
    - name: 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/chcon/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      register: audit_chcon_rule_status_check

    # 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Audit
    - name: 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/chcon/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      register: audit_chcon_running_rule_status_check

    # Extract audit result
    - set_fact:
        audit_chcon_rule_check:
          name: 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded
          scored: true
          automated: true
          remediation_status: "{{ true if ( system_min_uid.stdout != '' and (audit_chcon_rule_status_check.stdout | int) > 0 and (audit_chcon_running_rule_status_check.stdout | int) > 0) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_chcon_rule_check] }}"
      changed_when: false
    
    # 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Remediation
    - name: 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-chcon-perm-chng.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_chcon_rule_check.remediation_status
    
    # 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Remediation
    - name: 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/chcon/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -S all -F path=/usr/bin/chcon -F perm=x -F auid>={{ system_min_uid.stdout }} -F auid!=-1 -F key=perm_chng' >> /etc/audit/rules.d/00-cis-chcon-perm-chng.rules
      when: not audit_only and not audit_chcon_rule_check.remediation_status

     # 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Remediation
    - name: 5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_chcon_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded
  #
  # The operating system must generate audit records for successful/unsuccessful uses of
  # the setfacl command
  - name: "5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded"
    block:    
    # 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Audit
    - name: 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/setfacl/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      register: audit_setfacl_rule_status_check

    # 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Audit
    - name: 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/setfacl/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      register: audit_setfacl_running_rule_status_check

    # Extract audit result
    - set_fact:
        audit_setfacl_rule_check:
          name: 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded
          scored: true
          automated: true
          remediation_status: "{{ true if ( system_min_uid.stdout != '' and (audit_setfacl_rule_status_check.stdout | int) > 0 and (audit_setfacl_running_rule_status_check.stdout | int) > 0) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_setfacl_rule_check] }}"
      changed_when: false
    
    # 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Remediation
    - name: 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-setfacl-perm-chng.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_setfacl_rule_check.remediation_status
    
    # 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Remediation
    - name: 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/setfacl/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -S all -F path=/usr/bin/setfacl -F perm=x -F auid>={{ system_min_uid.stdout }} -F auid!=-1 -F key=perm_chng' >> /etc/audit/rules.d/00-cis-setfacl-perm-chng.rules
      when: not audit_only and not audit_setfacl_rule_check.remediation_status

     # 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Remediation
    - name: 5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_setfacl_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded
  #
  # The operating system must generate audit records for successful/unsuccessful uses of
  # the chacl command
  - name: "5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded"
    block:    
    # 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Audit
    - name: 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/chacl/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      register: audit_chacl_rule_status_check

    # 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Audit
    - name: 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/chacl/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      register: audit_chacl_running_rule_status_check

    # Extract audit result
    - set_fact:
        audit_chacl_rule_check:
          name: 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded
          scored: true
          automated: true
          remediation_status: "{{ true if ( system_min_uid.stdout != '' and (audit_chacl_rule_status_check.stdout | int) > 0 and (audit_chacl_running_rule_status_check.stdout | int) > 0) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_chacl_rule_check] }}"
      changed_when: false
    
    # 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Remediation
    - name: 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-chacl-perm-chng.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_chacl_rule_check.remediation_status
    
    # 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Remediation
    - name: 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/chacl/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>={{ system_min_uid.stdout }} -F auid!=unset -k perm_chng' >> /etc/audit/rules.d/00-cis-chacl-perm-chng.rules
      when: not audit_only and not audit_chacl_rule_check.remediation_status

     # 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Remediation
    - name: 5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_chacl_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded
  #
  # The operating system must generate audit records for successful/unsuccessful uses of
  # the usermod command.
  - name: "5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded"
    block:    
    # 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Audit
    - name: 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/sbin\/usermod/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      register: audit_usermod_rule_status_check

    # 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Audit
    - name: 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/sbin\/usermod/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      register: audit_usermod_running_rule_status_check

    # Extract audit result
    - set_fact:
        audit_usermod_rule_check:
          name: 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded
          scored: true
          automated: true
          remediation_status: "{{ true if ( system_min_uid.stdout != '' and (audit_usermod_rule_status_check.stdout | int) > 0 and (audit_usermod_running_rule_status_check.stdout | int) > 0) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_usermod_rule_check] }}"
      changed_when: false
    
    # 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Remediation
    - name: 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-usermod.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_usermod_rule_check.remediation_status
    
    # 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Remediation
    - name: 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/sbin\/usermod/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>={{ system_min_uid.stdout }} -F auid!=unset -k usermod' >> /etc/audit/rules.d/00-cis-usermod.rules
      when: not audit_only and not audit_usermod_rule_check.remediation_status

     # 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Remediation
    - name: 5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_usermod_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.19 Ensure kernel module loading unloading and modification is collected
  #
  # Monitor the loading and unloading of kernel modules. All the loading / listing /
  # dependency checking of modules is done by kmod via symbolic links.
  # 
  # The following system calls control loading and unloading of modules:
  #
  #
  # - init_module   : load a module
  # - finit_module  : load a module (used when the overhead of using cryptographically signed modules to determine the authenticity of a module can be avoided)
  # - delete_module : delete a module
  # - create_module : create a loadable module entry
  # - query_module  : query the kernel for various bits pertaining to modules
  #
  # Any execution of the loading and unloading module programs and system calls will
  # trigger an audit record with an identifier of modules .
  - name: "5.2.3.19 Ensure kernel module loading unloading and modification is collected"
    block:    
    # 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Audit
    - name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Audit
      shell:
        cmd: |
          awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item }}/ \
          &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&(/init_module,finit_module,delete_module,create_module,query_module/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_kernel_module_syscall_rule_status_check

    # 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Audit
    - name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Audit
      shell:
        cmd: |
          auditctl -l | awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item }}/ \
          &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&(/create_module,init_module,delete_module,query_module,finit_module/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | wc -l
      changed_when: false
      loop:
      - "32"
      - "64"
      register: audit_kernel_module_syscall_running_rule_status_check

    # Set kernel module syscall rules audit result
    - set_fact:
        audit_kernel_module_syscall_status: "{{ true if system_min_uid.stdout != '' else false }}"
      changed_when: false

    # Check if all kernel module syscall rules rules are configured
    - set_fact:
        audit_kernel_module_syscall_status: "{{ true if (audit_kernel_module_syscall_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_kernel_module_syscall_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false
    
    # Check if all kernel module syscall rules are loaded
    - set_fact:
        audit_kernel_module_syscall_status: "{{ true if (audit_kernel_module_syscall_status and (item.stdout | int) > 0) else false}}"
      loop: "{{ audit_kernel_module_syscall_running_rule_status_check.results | default([]) | list }}"
      loop_control:
        label: "{{ item.stdout | default() }}"
      changed_when: false

    # 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Audit
    - name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Audit
      shell:
        cmd: |
          awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/kmod/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l
      changed_when: false
      register: audit_kernel_module_rule_status_check

    # 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Audit
    - name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Audit
      shell:
        cmd: |
          auditctl -l | awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/kmod/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" | wc -l
      changed_when: false
      register: audit_kernel_module_running_rule_status_check

    # Set kernel module rules audit result
    - set_fact:
        audit_kernel_module_status: "{{ true if (system_min_uid.stdout != '' and (audit_kernel_module_rule_status_check.stdout | int) > 0 and (audit_kernel_module_running_rule_status_check.stdout | int) > 0) else false }}"
      changed_when: false

    # Extract audit result
    - set_fact:
        audit_kernel_module_rule_check:
          name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected
          scored: true
          automated: true
          remediation_status: "{{ true if (audit_kernel_module_syscall_status and audit_kernel_module_status) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_kernel_module_rule_check] }}"
      changed_when: false
    
    # 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Remediation
    - name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Remediation
      copy:
        dest: /etc/audit/rules.d/00-cis-kernel-modules.rules
        content: ''
        mode: "0600"
        owner: root
      when: not audit_only and not audit_kernel_module_rule_check.remediation_status
    
    # 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Remediation
    - name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b{{ item }}/ \
          &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -S/ \
          &&(/init_module,finit_module,delete_module,create_module,query_module/) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F arch=b{{ item }} -S init_module,finit_module,delete_module,create_module,query_module -F auid>={{ system_min_uid.stdout }} -F auid!=unset -k kernel_modules' >> /etc/audit/rules.d/00-cis-kernel-modules.rules
      loop:
      - "32"
      - "64"
      when: not audit_only and not audit_kernel_module_rule_check.remediation_status

    # 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Remediation
    - name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Remediation
      shell:
        cmd: |
          rule_count=$(awk "/^ *-a *always,exit/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&/ -F *auid>={{ system_min_uid.stdout }}/ \
          &&/ -F *perm=x/ \
          &&/ -F *path=\/usr\/bin\/kmod/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | wc -l)

          [[ "$rule_count" -gt 0 ]] || echo '-a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>={{ system_min_uid.stdout }} -F auid!=unset -k kernel_modules' >> /etc/audit/rules.d/00-cis-kernel-modules.rules
      when: not audit_only and not audit_kernel_module_rule_check.remediation_status

     # 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Remediation
    - name: 5.2.3.19 Ensure kernel module loading unloading and modification is collected | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_kernel_module_rule_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.20 Ensure the audit configuration is immutable
  #
  # Set system audit so that audit rules cannot be modified with auditctl . Setting the flag
  # "-e 2" forces audit to be put in immutable mode. Audit changes can only be made on
  # system reboot.
  # 
  # Note: This setting will require the system to be rebooted to update the active auditd
  # configuration settings.
  - name: "5.2.3.20 Ensure the audit configuration is immutable"
    block:    
    # 5.2.3.20 Ensure the audit configuration is immutable | Audit
    - name: 5.2.3.20 Ensure the audit configuration is immutable | Audit
      shell:
        cmd: grep -Phq -- '^\h*-e\h+2\b' /etc/audit/rules.d/*.rules && echo 'configured' || echo 'not_configured'
      changed_when: false
      register: audit_immutable_conf_status_check

    # Extract audit result
    - set_fact:
        audit_immutable_conf_check:
          name: 5.2.3.20 Ensure the audit configuration is immutable
          scored: true
          automated: true
          remediation_status: "{{ true if audit_immutable_conf_status_check.stdout == 'configured' else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_immutable_conf_check] }}"
      changed_when: false
    
    # 5.2.3.20 Ensure the audit configuration is immutable | Remediation
    - name: 5.2.3.20 Ensure the audit configuration is immutable | Remediation
      copy:
        dest: /etc/audit/rules.d/99-cis-finalize.rules
        # Break line is required
        content: |
          -e 2

        mode: "0600"
        owner: root
      when: not audit_only and not audit_immutable_conf_check.remediation_status

     # 5.2.3.20 Ensure the audit configuration is immutable | Remediation
    - name: 5.2.3.20 Ensure the audit configuration is immutable | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_immutable_conf_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"



  # 5.2.3.21 Ensure the running and on disk configuration is the same
  #
  # The Audit system have both on disk and running configuration. It is possible for these
  # configuration settings to differ.
  # Note: Due to the limitations of augenrules and auditctl , it is not absolutely guaranteed
  # that loading the rule sets via augenrules --load will result in all rules being loaded or
  # even that the user will be informed if there was a problem loading the rules.
  - name: "5.2.3.21 Ensure the running and on disk configuration is the same"
    block:    
    # 5.2.3.21 Ensure the running and on disk configuration is the same | Audit
    - name: 5.2.3.21 Ensure the running and on disk configuration is the same | Audit
      shell:
        cmd: augenrules --check | grep -qi 'no change' && echo 'configured' || echo 'not_configured'
      changed_when: false
      register: audit_all_rules_loaded_status_check

    # Extract audit result
    - set_fact:
        audit_all_rules_loaded_check:
          name: 5.2.3.21 Ensure the running and on disk configuration is the same
          scored: true
          automated: false
          remediation_status: "{{ true if audit_all_rules_loaded_status_check.stdout == 'configured' else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [audit_all_rules_loaded_check] }}"
      changed_when: false

     # 5.2.3.21 Ensure the running and on disk configuration is the same | Remediation
    - name: 5.2.3.21 Ensure the running and on disk configuration is the same | Remediation
      shell:
        cmd: augenrules --load
      when: not audit_only and not audit_all_rules_loaded_check.remediation_status
    tags:
    - "server_level_2"
    - "workstation_level_2"
    when: "'server_level_2' in levels or 'workstation_level_2' in levels"