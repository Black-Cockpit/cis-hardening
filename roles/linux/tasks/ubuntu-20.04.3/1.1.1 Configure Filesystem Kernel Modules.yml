- name: "1.1 Filesystem"
  block:
    - name: "1.1.1 Configure Filesystem Kernel Modules"
      block:
        - name: "1.1.1.1 Ensure cramfs kernel module is not available (Automated)"
          block:
            - name: "1.1.1.1 Ensure cramfs kernel module is not available | Audit"
              shell: |
                if lsmod | grep -q cramfs; then echo loaded; else echo not_loaded; fi
              changed_when: false
              register: cramfs_check_loaded_result

            - name: "1.1.1.1 Ensure cramfs kernel module is not available | Audit"
              shell: |
                if grep -r -E "^(#)?install cramfs /bin/false" /etc/modprobe.d/; then echo disabled; else echo not_disabled; fi
              changed_when: false
              register: cramfs_check_disabled_result

            - name: "1.1.1.1 Ensure cramfs kernel module is not available | Audit"
              shell: |
                if grep -r -E "^(#)?blacklist cramfs" /etc/modprobe.d/; then echo blacklisted; else echo not_blacklisted; fi
              changed_when: false
              register: cramfs_check_blacklisted_result

            - name: "1.1.1.1 Ensure cramfs kernel module is not available | Set Fact"
              set_fact:
                cramfs_check:
                  name: 1.1.1.1 Ensure cramfs kernel module is not available
                  scored: true
                  automated: true
                  remediation_status: "{{ 'true' if (cramfs_check_loaded_result.stdout == 'not_loaded' or (cramfs_check_disabled_result.stdout == 'disabled' and cramfs_check_blacklisted_result.stdout == 'blacklisted')) else 'false' }}"
              changed_when: false

            - name: "1.1.1.1 Ensure cramfs kernel module is not available | Append Result"
              set_fact:
                audit_result: "{{ (audit_result | default([])) + [cramfs_check] }}"
              changed_when: false

            - name: "1.1.1.1 Ensure cramfs kernel module is not available  dis| Remediation"
              lineinfile:
                path: "/etc/modprobe.d/cramfs.conf"
                regexp: "^(#)?install cramfs(\\s|$)"
                line: "install cramfs /bin/false"
                mode: "0600"
              when: cramfs_check.remediation_status == 'false'

            - name: "1.1.1.1 Ensure cramfs kernel module is not available bqls| Remediation"
              lineinfile:
                path: /etc/modprobe.d/blacklist.conf
                regexp: "^(#)?blacklist cramfs(\\s|$)"
                line: "blacklist cramfs"
                create: true
                mode: "0600"
              when:  cramfs_check.remediation_status == 'false'

            - name: "Disabling cramfs filesystems | Remediation"
              modprobe:
                name: cramfs
                state: absent
              when: cramfs_check.remediation_status == 'false'
          tags:
            - "server_level_1"
            - "workstation_level_1"
          when: "'server_level_1' in levels or 'workstation_level_1' in levels"






# 1.1.1.2 Ensure freevxfs kernel module is not available
#
# The freevxfs filesystem type is a free version of the Veritas type filesystem. This is the
# primary filesystem type for HP-UX operating systems.
- name: "1.1.1.2 Ensure freevxfs kernel module is not available"
  block:
    # 1.1.1.2 Ensure freevxfs kernel module is not available | Audit
    - name: "1.1.1.2 Ensure freevxfs kernel module is not available | Audit"
      shell: "modprobe -nq freevxfs && echo loaded || echo not_loaded"
      changed_when: false
      register: freevxfs_check_loaded_result
   
    # Check if module is disabled
    - name: "1.1.1.2 Ensure freevxfs kernel module is not available | Audit"
      shell: "grep -E '^(#)?install freevxfs /bin/false' /etc/modprobe.d/* && echo disabled || echo not_disabled"
      changed_when: false
      register: freevxfs_check_disabled_result
   
    # Check if module is blacklisted
    - name: "1.1.1.2 Ensure freevxfs kernel module is not available | Audit"
      shell: "grep -E '^(#)?blacklist freevxfs' /etc/modprobe.d/* && echo blacklisted || echo not_blacklisted"
      changed_when: false
      register: freevxfs_check_blacklisted_result
   
    # Extract audit result
    - set_fact:
        freevxfs_check:
          name: "1.1.1.2 Ensure freevxfs kernel module is not available"
          scored: true
          automated: true
          remediation_status: "{{ 'true' if (freevxfs_check_loaded_result.stdout == 'not_loaded' or (freevxfs_check_disabled_result.stdout == 'disabled' and freevxfs_check_blacklisted_result.stdout == 'blacklisted')) else 'false' }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [freevxfs_check] }}"
      changed_when: false

    # 1.1.1.2 Ensure freevxfs kernel module is not available | Remediation
    - name: "1.1.1.2 Ensure freevxfs kernel module is not available  dis| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/freevxfs.conf"
        regexp: "^(#)?install freevxfs(\\s|$)"
        line: "install freevxfs /bin/false"
        create: true
        mode: "0644"
      when: freevxfs_check.remediation_status == 'false'

    - name: "1.1.1.2 Ensure freevxfs kernel module is not available  blqck| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/blacklist.conf"
        regexp: "^(#)?blacklist freevxfs(\\s|$)"
        line: "blacklist freevxfs"
        create: true
        mode: "0644"
      when: freevxfs_check.remediation_status == 'false'

    # Disable freevxfs filesystems
    - name: "Disabling freevxfs filesystems | Remediation"
      modprobe:
        name: freevxfs
        state: absent
      when:  freevxfs_check.remediation_status == 'false'
  tags:
    - "server_level_1"
    - "workstation_level_1"
  when: "'server_level_1' in levels or 'workstation_level_1' in levels"

# 1.1.1.3 Ensure hfs kernel module is not available
#
# The hfs filesystem type is a hierarchical filesystem that allows you to mount Mac OS
# filesystems.
- name: "1.1.1.3 Ensure hfs kernel module is not available"
  block:
    # 1.1.1.3 Ensure hfs kernel module is not available | Audit
    - name: "1.1.1.3 Ensure hfs kernel module is not available | Audit"
      shell: "modprobe -nq hfs && echo loaded || echo not_loaded"
      changed_when: false
      register: hfs_check_loaded_result
   
    # Check if module is disabled
    - name: "1.1.1.3 Ensure hfs kernel module is not available | Audit"
      shell: "grep -E '^(#)?install hfs /bin/false' /etc/modprobe.d/* && echo disabled || echo not_disabled"
      changed_when: false
      register: hfs_check_disabled_result
   
    # Check if module is blacklisted
    - name: "1.1.1.3 Ensure hfs kernel module is not available | Audit"
      shell: "grep -E '^(#)?blacklist hfs' /etc/modprobe.d/* && echo blacklisted || echo not_blacklisted"
      changed_when: false
      register: hfs_check_blacklisted_result
   
    # Extract audit result
    - set_fact:
        hfs_check:
          name: "1.1.1.3 Ensure hfs kernel module is not available"
          scored: true
          automated: true
          remediation_status: "{{ 'true' if (hfs_check_loaded_result.stdout == 'not_loaded' or (hfs_check_disabled_result.stdout == 'disabled' and hfs_check_blacklisted_result.stdout == 'blacklisted')) else 'false' }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [hfs_check] }}"
      changed_when: false

    # 1.1.1.3 Ensure hfs kernel module is not available | Remediation
    - name: "1.1.1.3 Ensure hfs kernel module is not available  blqck| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/hfs.conf"
        regexp: "^(#)?install hfs(\\s|$)"
        line: "install hfs /bin/false"
        create: true
        mode: "0644"
      when:  hfs_check.remediation_status == 'false'

    - name: "1.1.1.3 Ensure hfs kernel module is not available  dis| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/blacklist.conf"
        regexp: "^(#)?blacklist hfs(\\s|$)"
        line: "blacklist hfs"
        create: true
        mode: "0644"
      when: hfs_check.remediation_status == 'false'

    # Disable hfs filesystems
    - name: "Disabling hfs filesystems | Remediation"
      modprobe:
        name: hfs
        state: absent
      when: hfs_check.remediation_status == 'false'
  tags:
    - "server_level_1"
    - "workstation_level_1"
  when: "'server_level_1' in levels or 'workstation_level_1' in levels"



# 1.1.1.4 Ensure hfsplus kernel module is not available
#
# The hfsplus filesystem type is a hierarchical filesystem designed to replace hfs that
# allows you to mount Mac OS filesystems.
- name: "1.1.1.4 Ensure hfsplus kernel module is not available"
  block:
    # 1.1.1.4 Ensure hfsplus kernel module is not available | Audit
    - name: "1.1.1.4 Ensure hfsplus kernel module is not available | Audit"
      shell: "modprobe -nq hfsplus && echo loaded || echo not_loaded"
      changed_when: false
      register: hfsplus_check_loaded_result
   
    # Check if module is disabled
    - name: "1.1.1.4 Ensure hfsplus kernel module is not available | Audit"
      shell: "grep -E '^(#)?install hfsplus /bin/false' /etc/modprobe.d/* && echo disabled || echo not_disabled"
      changed_when: false
      register: hfsplus_check_disabled_result
   
    # Check if module is blacklisted
    - name: "1.1.1.4 Ensure hfsplus kernel module is not available | Audit"
      shell: "grep -E '^(#)?blacklist hfsplus' /etc/modprobe.d/* && echo blacklisted || echo not_blacklisted"
      changed_when: false
      register: hfsplus_check_blacklisted_result
   
    # Extract audit result
    - set_fact:
        hfsplus_check:
          name: "1.1.1.4 Ensure hfsplus kernel module is not available"
          scored: true
          automated: true
          remediation_status: "{{ 'true' if (hfsplus_check_loaded_result.stdout == 'not_loaded' or (hfsplus_check_disabled_result.stdout == 'disabled' and hfsplus_check_blacklisted_result.stdout == 'blacklisted')) else 'false' }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [hfsplus_check] }}"
      changed_when: false

    # 1.1.1.4 Ensure hfsplus kernel module is not available | Remediation
    - name: "1.1.1.4 Ensure hfsplus kernel module is not available  dis| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/hfsplus.conf"
        regexp: "^(#)?install hfsplus(\\s|$)"
        line: "install hfsplus /bin/false"
        create: true
        mode: "0644"
      when: hfsplus_check.remediation_status == 'false'

    - name: "1.1.1.4 Ensure hfsplus kernel module is not available blqck | Remediation"
      lineinfile:
        path: "/etc/modprobe.d/blacklist.conf"
        regexp: "^(#)?blacklist hfsplus(\\s|$)"
        line: "blacklist hfsplus"
        create: true
        mode: "0644"
      when: hfsplus_check.remediation_status == 'false'

    # Disable hfsplus filesystems
    - name: "Disabling hfsplus filesystems | Remediation"
      modprobe:
        name: hfsplus
        state: absent
      when: hfsplus_check.remediation_status == 'false'
  tags:
    - "server_level_1"
    - "workstation_level_1"
  when: "'server_level_1' in levels or 'workstation_level_1' in levels"

# 1.1.1.5 Ensure jffs2 kernel module is not available
#
# The jffs2 (journaling flash filesystem 2) filesystem type is a log-structured filesystem
# used in flash memory devices.
- name: "1.1.1.5 Ensure jffs2 kernel module is not available"
  block:
    # 1.1.1.5 Ensure jffs2 kernel module is not available | Audit
    - name: "1.1.1.5 Ensure jffs2 kernel module is not available | Audit"
      shell: "modprobe -nq jffs2 && echo loaded || echo not_loaded"
      changed_when: false
      register: jffs2_check_loaded_result
   
    # Check if module is disabled
    - name: "1.1.1.5 Ensure jffs2 kernel module is not available | Audit"
      shell: "grep -E '^(#)?install jffs2 /bin/false' /etc/modprobe.d/* && echo disabled || echo not_disabled"
      changed_when: false
      register: jffs2_check_disabled_result
   
    # Check if module is blacklisted
    - name: "1.1.1.5 Ensure jffs2 kernel module is not available | Audit"
      shell: "grep -E '^(#)?blacklist jffs2' /etc/modprobe.d/* && echo blacklisted || echo not_blacklisted"
      changed_when: false
      register: jffs2_check_blacklisted_result
   
    # Extract audit result
    - set_fact:
        jffs2_check:
          name: "1.1.1.5 Ensure jffs2 kernel module is not available"
          scored: true
          automated: true
          remediation_status: "{{ 'true' if (jffs2_check_loaded_result.stdout == 'not_loaded' or (jffs2_check_disabled_result.stdout == 'disabled' and jffs2_check_blacklisted_result.stdout == 'blacklisted')) else 'false' }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [jffs2_check] }}"
      changed_when: false

    # 1.1.1.5 Ensure jffs2 kernel module is not available | Remediation
    - name: "1.1.1.5 Ensure jffs2 kernel module is not available  dis| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/jffs2.conf"
        regexp: "^(#)?install jffs2(\\s|$)"
        line: "install jffs2 /bin/false"
        create: true
        mode: "0644"
      when: jffs2_check.remediation_status == 'false'

    - name: "1.1.1.5 Ensure jffs2 kernel module is not available  black| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/blacklist.conf"
        regexp: "^(#)?blacklist jffs2(\\s|$)"
        line: "blacklist jffs2"
        create: true
        mode: "0644"
      when: jffs2_check.remediation_status == 'false'

    # Disable jffs2 filesystems
    - name: "Disabling jffs2 filesystems | Remediation"
      modprobe:
        name: jffs2
        state: absent
      when: jffs2_check.remediation_status == 'false'
  tags:
    - "server_level_1"
    - "workstation_level_1"
  when: "'server_level_1' in levels or 'workstation_level_1' in levels"

# 1.1.1.6 Ensure squashfs kernel module is not available
#
# The squashfs filesystem type is a compressed read-only Linux filesystem embedded in
# small footprint systems. A squashfs image can be used without having to first
# decompress the image.
- name: "1.1.1.6 Ensure squashfs kernel module is not available"
  block:
    # 1.1.1.6 Ensure squashfs kernel module is not available | Audit
    - name: "1.1.1.6 Ensure squashfs kernel module is not available | Audit"
      shell: "modprobe -nq squashfs && echo loaded || echo not_loaded"
      changed_when: false
      register: squashfs_check_loaded_result
   
    # Check if module is disabled
    - name: "1.1.1.6 Ensure squashfs kernel module is not available | Audit"
      shell: "grep -E '^(#)?install squashfs /bin/false' /etc/modprobe.d/* && echo disabled || echo not_disabled"
      changed_when: false
      register: squashfs_check_disabled_result
   
    # Check if module is blacklisted
    - name: "1.1.1.6 Ensure squashfs kernel module is not available | Audit"
      shell: "grep -E '^(#)?blacklist squashfs' /etc/modprobe.d/* && echo blacklisted || echo not_blacklisted"
      changed_when: false
      register: squashfs_check_blacklisted_result
   
    # Extract audit result
    - set_fact:
        squashfs_check:
          name: "1.1.1.6 Ensure squashfs kernel module is not available"
          scored: true
          automated: true
          remediation_status: "{{ 'true' if (squashfs_check_loaded_result.stdout == 'not_loaded' or (squashfs_check_disabled_result.stdout == 'disabled' and squashfs_check_blacklisted_result.stdout == 'blacklisted')) else 'false' }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [squashfs_check] }}"
      changed_when: false

    # 1.1.1.6 Ensure squashfs kernel module is not available | Remediation
    - name: "1.1.1.6 Ensure squashfs kernel module is not available dis| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/squashfs.conf"
        regexp: "^(#)?install squashfs(\\s|$)"
        line: "install squashfs /bin/false"
        create: true
        mode: "0644"
      when: squashfs_check.remediation_status == 'false'

    - name: "1.1.1.6 Ensure squashfs kernel module is not available blqsk| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/blacklist.conf"
        regexp: "^(#)?blacklist squashfs(\\s|$)"
        line: "blacklist squashfs"
        create: true
        mode: "0644"
      when:  squashfs_check.remediation_status == 'false'

    # Disable squashfs filesystems
    - name: "Disabling squashfs filesystems | Remediation"
      shell: "rmmod squashfs || true"
      when: squashfs_check.remediation_status == 'false'
      ignore_errors: true

  tags:
    - "server_level_1"
    - "workstation_level_1"
  when: "'server_level_1' in levels or 'workstation_level_1' in levels"


# 1.1.1.7 Ensure udf kernel module is not available
  #
  # The udf filesystem type is the universal disk format used to implement ISO/IEC 13346
  # and ECMA-167 specifications. This is an open vendor filesystem type for data storage
  # on a broad range of media. This filesystem type is necessary to support writing DVDs
  # and newer optical disc formats.
- name: "1.1.1.7 Ensure udf kernel module is not available"
  block:
    # 1.1.1.7 Ensure udf kernel module is not available | Audit
    - name: "1.1.1.7 Ensure udf kernel module is not available | Audit"
      shell:
        cmd: modprobe -nqv udf && echo loaded || echo not_loaded
      changed_when: false
      register: udf_check_loaded_result
    # Check if module is disabled
    - name: "1.1.1.7 Ensure udf kernel module is not available | Audit"
      shell:
        cmd: grep -r -E "^(#)?install udf /bin/false" /etc/modprobe.d/ > /dev/null && echo disabled || echo not_disabled
      changed_when: false
      register: udf_check_disabled_result
    # Check if module is blacklisted
    - name: "1.1.1.7 Ensure udf kernel module is not available | Audit"
      shell:
        cmd: grep -r -E "^(#)?blacklist udf" /etc/modprobe.d/ > /dev/null && echo blacklisted || echo not_blacklisted
      changed_when: false
      register: udf_check_blacklisted_result
    # Extract audit result
    - set_fact:
        udf_check:
          name: 1.1.1.7 Ensure udf kernel module is not available
          scored: true
          automated: true
          remediation_status: "{{ true if (udf_check_loaded_result.stdout == 'not_loaded' or (udf_check_disabled_result.stdout == 'disabled' and udf_check_blacklisted_result.stdout == 'blacklisted')) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [udf_check] }}"
      changed_when: false

    # 1.1.1.7 Ensure udf kernel module is not available | Remediation
    - name: "1.1.1.7 Ensure udf kernel module is not available dis| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/udf.conf"
        regexp: "^(#)?install udf(\\s|$)"
        line: "install udf /bin/false"
        create: true
      when: not udf_check.remediation_status

    - name: "1.1.1.7 Ensure udf kernel module is not available blqs | Remediation"
      lineinfile:
        path: /etc/modprobe.d/blacklist.conf
        regexp: "^(#)?blacklist udf(\\s|$)"
        line: "blacklist udf"
        create: true
        mode: "0600"
      when: not udf_check.remediation_status

    # Disable udf filesystems
    - name: Disabling udf filesystems | Remediation
      modprobe:
        name: udf
        state: absent
      when: not udf_check.remediation_status
      tags:
        - "server_level_2"
        - "workstation_level_2"
  when: "'server_level_2' in levels or 'workstation_level_2' in levels"



# 1.1.1.8 Ensure usb-storage kernel module is not available
  #
  # USB storage provides a means to transfer and store files ensuring persistence and
  # availability of the files independent of network connection status. Its popularity and utility
  # has led to USB-based malware being a simple and common means for network
  # infiltration and a first step to establishing a persistent threat within a networked
- name: "1.1.1.8 Ensure usb-storage kernel module is not available"
  block:
    # 1.1.1.8 Ensure usb-storage kernel module is not available | Audit
    - name: "1.1.1.8 Ensure usb-storage kernel module is not available | Audit"
      shell:
        cmd: modprobe -nqv usb-storage && echo loaded || echo not_loaded
      changed_when: false
      register: usb_storage_check_loaded_result
    # Check if module is disabled
    - name: "1.1.1.8 Ensure usb-storage kernel module is not available | Audit"
      shell:
        cmd: grep -r -E "^(#)?install usb-storage /bin/false" /etc/modprobe.d/ > /dev/null && echo disabled || echo not_disabled
      changed_when: false
      register: usb_storage_check_disabled_result
    # Check if module is blacklisted
    - name: "1.1.1.8 Ensure usb-storage kernel module is not available | Audit"
      shell:
        cmd: grep -r -E "^(#)?blacklist usb-storage" /etc/modprobe.d/ > /dev/null && echo blacklisted || echo not_blacklisted
      changed_when: false
      register: usb_storage_check_blacklisted_result
    # Extract audit result
    - set_fact:
        usb_storage_check:
          name: 1.1.1.8 Ensure usb-storage kernel module is not available
          scored: true
          automated: true
          remediation_status: "{{ true if (usb_storage_check_loaded_result.stdout == 'not_loaded' or (usb_storage_check_disabled_result.stdout == 'disabled' and usb_storage_check_blacklisted_result.stdout == 'blacklisted')) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [usb_storage_check] }}"
      changed_when: false

    # 1.1.1.8 Ensure usb-storage kernel module is not available | Remediation
    - name: "1.1.1.8 Ensure usb-storage kernel module is not available dis| Remediation"
      lineinfile:
        path: "/etc/modprobe.d/usb-storage.conf"
        regexp: "^(#)?install usb-storage(\\s|$)"
        line: "install usb-storage /bin/false"
        create: true
      when: not usb_storage_check.remediation_status

    - name: "1.1.1.8 Ensure usb-storage kernel module is not available blqs| Remediation"
      lineinfile:
        path: /etc/modprobe.d/blacklist.conf
        regexp: "^(#)?blacklist usb-storage(\\s|$)"
        line: "blacklist usb-storage"
        create: true
        mode: "0600"
      when: not usb_storage_check.remediation_status

    # Disable usb-storage filesystems
    - name: Disabling usb-storage filesystems | Remediation
      modprobe:
        name: usb-storage
        state: absent
      when: not usb_storage_check.remediation_status
      tags:
        - "server_level_2"
        - "workstation_level_2"
  when: "'server_level_2' in levels or 'workstation_level_2' in levels"
