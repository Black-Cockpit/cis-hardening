# 2.2 Configure Special Purpose Services
- name: 2.2 Configure Special Purpose Services
  block:
  # 2.2.1 Ensure autofs services are not in use
  #
  # autofs allows automatic mounting of devices, typically including CD/DVDs and USB
  # drives.
  - name: "2.2.1 Ensure autofs services are not in use"
    block:
    # 2.2.1 Ensure autofs services are not in use | Audit
    - name: 2.2.1 Ensure autofs services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q autofs && echo installed || echo not_installed
      changed_when: false
      register: autofs_status_check

    # 2.2.1 Ensure autofs services are not in use | Audit
    - name: 2.2.1 Ensure autofs services are not in use | Audit
      systemd:
        name: autofs
      ignore_errors: yes
      changed_when: false
      register: autofs_service_status_check
      when: autofs_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        autofs_check:
          name: 2.2.1 Ensure autofs services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (autofs_status_check.stdout == 'not_installed' or (autofs_service_status_check.status.ActiveState == 'inactive' and (autofs_service_status_check.status.UnitFileState is not defined or autofs_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [autofs_check] }}"
      changed_when: false

    # 2.2.1 Ensure autofs services are not in use | Remediation
    - name: 2.2.1 Ensure autofs services are not in use | Remediation
      systemd:
        name: autofs
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not autofs_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_2"
    when: "'server_level_1' in levels or 'workstation_level_2' in levels"



  # 2.2.2 Ensure avahi daemon services are not in use
  #
  # Avahi is a free zeroconf implementation, including a system for multicast DNS/DNS-SD
  # service discovery. Avahi allows programs to publish and discover services and hosts
  # running on a local network with no specific configuration. For example, a user can plug
  # a computer into a network and Avahi automatically finds printers to print to, files to look
  # at and people to talk to, as well as network services running on the machine.
  - name: "2.2.2 Ensure avahi daemon services are not in use"
    block:
    # 2.2.2 Ensure avahi daemon services are not in use | Audit
    - name: 2.2.2 Ensure avahi daemon services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q avahi && echo installed || echo not_installed
      changed_when: false
      register: avahi_status_check

    # 2.2.2 Ensure avahi daemon services are not in use | Audit
    - name: 2.2.2 Ensure avahi daemon services are not in use | Audit
      systemd:
        name: avahi
      ignore_errors: yes
      changed_when: false
      register: avahi_service_status_check
      when: avahi_status_check.stdout == 'installed'

    # Define remediation status
    - set_fact:
        avahi_remediation_status: "{{ true if (avahi_status_check.stdout == 'not_installed' or (avahi_service_status_check.status.ActiveState == 'inactive' and (avahi_service_status_check.status.UnitFileState is not defined or avahi_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      
      
    # 2.2.2 Ensure avahi daemon services are not in use | Audit
    - name: 2.2.2 Ensure avahi daemon services are not in use | Audit
      systemd:
        name: avahi-daemon.socket
      ignore_errors: yes
      changed_when: false
      register: avahi_socket_status_check
      when: avahi_status_check.stdout == 'installed'

    # Append to remediation status
    - set_fact:
        avahi_remediation_status: "{{ true if (avahi_remediation_status and (avahi_socket_status_check.status.ActiveState == 'inactive' and (avahi_socket_status_check.status.UnitFileState is not defined or avahi_socket_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: avahi_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        avahi_check:
          name: 2.2.2 Ensure avahi daemon services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if avahi_remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [avahi_check] }}"
      changed_when: false

    # 2.2.2 Ensure avahi daemon services are not in use | Remediation
    - name: 2.2.2 Ensure avahi daemon services are not in use | Remediation
      systemd:
        name: avahi
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not avahi_check.remediation_status
    
    # 2.2.2 Ensure avahi daemon services are not in use | Remediation
    - name: 2.2.2 Ensure avahi daemon services are not in use | Remediation
      systemd:
        name: avahi-daemon.socket
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not avahi_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_2"
    when: "'server_level_1' in levels or 'workstation_level_2' in levels"



  # 2.2.3 Ensure dhcp server services are not in use
  #
  # The Dynamic Host Configuration Protocol (DHCP) is a service that allows machines to
  # be dynamically assigned IP addresses. There are two versions of the DHCP protocol
  # DHCPv4 and DHCPv6 . At startup the server may be started for one or the other via the -4
  # or -6 arguments.
  - name: "2.2.3 Ensure dhcp server services are not in use"
    block:
    # 2.2.3 Ensure dhcp server services are not in use | Audit
    - name: 2.2.3 Ensure dhcp server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q "dhcp-server" && echo installed || echo not_installed
      changed_when: false
      register: dhcp_server_status_check

    # 2.2.3 Ensure dhcp server services are not in use | Audit
    - name: 2.2.3 Ensure dhcp server services are not in use | Audit
      systemd:
        name: dhcpd
      ignore_errors: yes
      changed_when: false
      register: dhcp_service_status_check
      when: dhcp_server_status_check.stdout == 'installed'

    # Define remediation status
    - set_fact:
        dhcp_remediation_status: "{{ true if (dhcp_server_status_check.stdout == 'not_installed' or (dhcp_service_status_check.status.ActiveState == 'inactive' and (dhcp_service_status_check.status.UnitFileState is not defined or dhcp_service_status_check.status.UnitFileState != 'enabled'))) else false }}"

    # 2.2.3 Ensure dhcp server services are not in use | Audit
    - name: 2.2.3 Ensure dhcp server services are not in use | Audit
      systemd:
        name: dhcpd6
      ignore_errors: yes
      changed_when: false
      register: dhcp6_service_status_check
      when: dhcp_server_status_check.stdout == 'installed'

    # Append to remediation status
    - set_fact:
        dhcp_remediation_status: "{{ true if (dhcp_remediation_status and (dhcp6_service_status_check.status.ActiveState == 'inactive' and (dhcp6_service_status_check.status.UnitFileState is not defined or dhcp6_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: dhcp_server_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        dhcp_check:
          name: 2.2.3 Ensure dhcp server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if dhcp_remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [dhcp_check] }}"
      changed_when: false

    # 2.2.3 Ensure dhcp server services are not in use | Remediation
    - name: 2.2.3 Ensure dhcp server services are not in use | Remediation
      systemd:
        name: dhcpd
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not dhcp_check.remediation_status
    
    # 2.2.3 Ensure dhcp server services are not in use | Remediation
    - name: 2.2.3 Ensure dhcp server services are not in use | Remediation
      systemd:
        name: dhcpd6
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not dhcp_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.4 Ensure dns server services are not in use
  #
  # The Domain Name System (DNS) is a hierarchical naming system that maps names to
  # IP addresses for computers, services and other resources connected to a network.
  - name: "2.2.4 Ensure dns server services are not in use"
    block:
    # 2.2.4 Ensure dns server services are not in use | Audit
    - name: 2.2.4 Ensure dns server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q bind && echo installed || echo not_installed
      changed_when: false
      register: bind_status_check

    # 2.2.4 Ensure dns server services are not in use | Audit
    - name: 2.2.4 Ensure dns server services are not in use | Audit
      systemd:
        name: named
      ignore_errors: yes
      changed_when: false
      register: named_service_status_check
      when: bind_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        bind_check:
          name: 2.2.4 Ensure dns server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (bind_status_check.stdout == 'not_installed' or (named_service_status_check.status.ActiveState == 'inactive' and (named_service_status_check.status.UnitFileState is not defined or named_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [bind_check] }}"
      changed_when: false

    # 2.2.4 Ensure dns server services are not in use | Remediation
    - name: 2.2.4 Ensure dns server services are not in use | Remediation
      systemd:
        name: named
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not bind_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.5 Ensure dnsmasq services are not in use
  #
  # dnsmasq is a lightweight tool that provides DNS caching, DNS forwarding and DHCP
  # (Dynamic Host Configuration Protocol) services.
  - name: "2.2.5 Ensure dnsmasq services are not in use"
    block:
    # 2.2.5 Ensure dnsmasq services are not in use | Audit
    - name: 2.2.5 Ensure dnsmasq services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q dnsmasq && echo installed || echo not_installed
      changed_when: false
      register: dnsmasq_status_check

    # 2.2.5 Ensure dnsmasq services are not in use | Audit
    - name: 2.2.5 Ensure dnsmasq services are not in use | Audit
      systemd:
        name: dnsmasq
      ignore_errors: yes
      changed_when: false
      register: dnsmasq_service_status_check
      when: dnsmasq_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        dnsmasq_check:
          name: 2.2.5 Ensure dnsmasq services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (dnsmasq_status_check.stdout == 'not_installed' or (dnsmasq_service_status_check.status.ActiveState == 'inactive' and (dnsmasq_service_status_check.status.UnitFileState is not defined or dnsmasq_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [dnsmasq_check] }}"
      changed_when: false

    # 2.2.5 Ensure dnsmasq services are not in use | Remediation
    - name: 2.2.5 Ensure dnsmasq services are not in use | Remediation
      systemd:
        name: dnsmasq
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not dnsmasq_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.6 Ensure samba file server services are not in use
  #
  # The Samba daemon allows system administrators to configure their Linux systems to
  # share file systems and directories with Windows desktops. Samba will advertise the file
  # systems and directories via the Server Message Block (SMB) protocol. Windows
  # desktop users will be able to mount these directories and file systems as letter drives on
  # their systems.
  - name: "2.2.6 Ensure samba file server services are not in use"
    block:
    # 2.2.6 Ensure samba file server services are not in use | Audit
    - name: 2.2.6 Ensure samba file server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q samba && echo installed || echo not_installed
      changed_when: false
      register: samba_status_check

    # 2.2.6 Ensure samba file server services are not in use | Audit
    - name: 2.2.6 Ensure samba file server services are not in use | Audit
      systemd:
        name: smb
      ignore_errors: yes
      changed_when: false
      register: smb_service_status_check
      when: samba_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        smb_check:
          name: 2.2.6 Ensure samba file server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (samba_status_check.stdout == 'not_installed' or (smb_service_status_check.status.ActiveState == 'inactive' and (smb_service_status_check.status.UnitFileState is not defined or smb_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [smb_check] }}"
      changed_when: false

    # 2.2.6 Ensure samba file server services are not in use | Remediation
    - name: 2.2.6 Ensure samba file server services are not in use | Remediation
      systemd:
        name: smb
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not smb_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.7 Ensure ftp server services are not in use
  #
  # FTP (File Transfer Protocol) is a traditional and widely used standard tool for
  # transferring files between a server and clients over a network, especially where no
  # authentication is necessary (permits anonymous users to connect to a server).
  - name: "2.2.7 Ensure ftp server services are not in use"
    block:
    # 2.2.7 Ensure ftp server services are not in use | Audit
    - name: 2.2.7 Ensure ftp server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q vsftpd && echo installed || echo not_installed
      changed_when: false
      register: vsftpd_status_check

    # 2.2.7 Ensure ftp server services are not in use | Audit
    - name: 2.2.7 Ensure ftp server services are not in use | Audit
      systemd:
        name: vsftpd
      ignore_errors: yes
      changed_when: false
      register: vsftpd_service_status_check
      when: vsftpd_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        vsftpd_check:
          name: 2.2.7 Ensure ftp server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (vsftpd_status_check.stdout == 'not_installed' or (vsftpd_service_status_check.status.ActiveState == 'inactive' and (vsftpd_service_status_check.status.UnitFileState is not defined or vsftpd_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [vsftpd_check] }}"
      changed_when: false

    # 2.2.7 Ensure ftp server services are not in use | Remediation
    - name: 2.2.7 Ensure ftp server services are not in use | Remediation
      systemd:
        name: vsftpd
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not vsftpd_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.8 Ensure message access server services are not in use
  #
  # dovecot and cyrus-imapd are open source IMAP and POP3 server packages for Linux
  # based systems.
  - name: "2.2.8 Ensure message access server services are not in use"
    block:
    # 2.2.8 Ensure message access server services are not in use | Audit
    - name: 2.2.8 Ensure message access server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q dovecot && echo installed || echo not_installed
      changed_when: false
      register: dovecot_status_check

    # 2.2.8 Ensure message access server services are not in use | Audit
    - name: 2.2.8 Ensure message access server services are not in use | Audit
      systemd:
        name: dovecot
      ignore_errors: yes
      changed_when: false
      register: dovecot_service_status_check
      when: dovecot_status_check.stdout == 'installed'

    # Define remediation status
    - set_fact:
        remediation_status: "{{ true if (dovecot_status_check.stdout == 'not_installed' or (dovecot_service_status_check.status.ActiveState == 'inactive' and (dovecot_service_status_check.status.UnitFileState is not defined or dovecot_service_status_check.status.UnitFileState != 'enabled'))) else false }}"

    # 2.2.8 Ensure message access server services are not in use | Audit
    - name: 2.2.8 Ensure message access server services are not in use | Audit
      systemd:
        name: dovecot.socket
      ignore_errors: yes
      changed_when: false
      register: dovecot_socket_status_check
      when: dovecot_status_check.stdout == 'installed'

    # Update remediation status
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (dovecot_socket_status_check.status.ActiveState == 'inactive' and (dovecot_socket_status_check.status.UnitFileState is not defined or dovecot_socket_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: dovecot_status_check.stdout == 'installed'

    # 2.2.8 Ensure message access server services are not in use | Audit
    - name: 2.2.8 Ensure message access server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q "cyrus-imapd" && echo installed || echo not_installed
      changed_when: false
      register: cyrus_imapd_status_check

    # 2.2.8 Ensure message access server services are not in use | Audit
    - name: 2.2.8 Ensure message access server services are not in use | Audit
      systemd:
        name: cyrus-imapd
      ignore_errors: yes
      changed_when: false
      register: cyrus_imapd_service_status_check
      when: cyrus_imapd_status_check.stdout == 'installed'

    # Update remediation status
    - set_fact:
        remediation_status: "{{ true if ((remediation_status or cyrus_imapd_status_check.stdout == 'not_installed') and (cyrus_imapd_service_status_check.status.ActiveState == 'inactive' and (cyrus_imapd_service_status_check.status.UnitFileState is not defined or cyrus_imapd_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: cyrus_imapd_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        message_access_check:
          name: 2.2.8 Ensure message access server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [message_access_check] }}"
      changed_when: false

    # 2.2.8 Ensure message access server services are not in use | Remediation
    - name: 2.2.8 Ensure message access server services are not in use | Remediation
      systemd:
        name: dovecot
        state: stopped
        enabled: false
        masked: true
        force: true
      when: dovecot_status_check.stdout == 'installed' and not audit_only and not message_access_check.remediation_status

    # 2.2.8 Ensure message access server services are not in use | Remediation
    - name: 2.2.8 Ensure message access server services are not in use | Remediation
      systemd:
        name: dovecot.socket
        state: stopped
        enabled: false
        masked: true
        force: true
      when: dovecot_status_check.stdout == 'installed' and not audit_only and not message_access_check.remediation_status

    # 2.2.8 Ensure message access server services are not in use | Remediation
    - name: 2.2.8 Ensure message access server services are not in use | Remediation
      systemd:
        name: cyrus-imapd
        state: stopped
        enabled: false
        masked: true
        force: true
      when: cyrus_imapd_status_check.stdout == 'installed' and not audit_only and not message_access_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.9 Ensure network file system services are not in use
  #
  # The Network File System (NFS) is one of the first and most widely distributed file
  # systems in the UNIX environment. It provides the ability for systems to mount file
  # systems of other servers through the network.
  - name: "2.2.9 Ensure network file system services are not in use"
    block:
    # 2.2.9 Ensure network file system services are not in use | Audit
    - name: 2.2.9 Ensure network file system services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q "nfs-utils" && echo installed || echo not_installed
      changed_when: false
      register: nfs_status_check

    # 2.2.9 Ensure network file system services are not in use | Audit
    - name: 2.2.9 Ensure network file system services are not in use | Audit
      systemd:
        name: nfs-server
      ignore_errors: yes
      changed_when: false
      register: nfs_service_status_check
      when: nfs_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        nfs_check:
          name: 2.2.9 Ensure network file system services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (nfs_status_check.stdout == 'not_installed' or (nfs_service_status_check.status.ActiveState == 'inactive' and (nfs_service_status_check.status.UnitFileState is not defined or nfs_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [nfs_check] }}"
      changed_when: false

    # 2.2.9 Ensure network file system services are not in use | Remediation
    - name: 2.2.9 Ensure network file system services are not in use | Remediation
      systemd:
        name: nfs-server
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not nfs_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.10 Ensure nis server services are not in use
  #
  # The Network Information Service (NIS), formerly known as Yellow Pages, is a client-
  # server directory service protocol used to distribute system configuration files. The NIS
  # client ( ypbind ) was used to bind a machine to an NIS server and receive the
  # distributed configuration files.
  - name: "2.2.10 Ensure nis server services are not in use"
    block:
    # 2.2.10 Ensure nis server services are not in use | Audit
    - name: 2.2.9 Ensure network file system services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q ypserv && echo installed || echo not_installed
      changed_when: false
      register: ypserv_status_check

    # 2.2.10 Ensure nis server services are not in use | Audit
    - name: 2.2.10 Ensure nis server services are not in use | Audit
      systemd:
        name: ypserv
      ignore_errors: yes
      changed_when: false
      register: ypserv_service_status_check
      when: ypserv_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        ypserv_check:
          name: 2.2.10 Ensure nis server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (ypserv_status_check.stdout == 'not_installed' or (ypserv_service_status_check.status.ActiveState == 'inactive' and (ypserv_service_status_check.status.UnitFileState is not defined or ypserv_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [ypserv_check] }}"
      changed_when: false

    # 2.2.10 Ensure nis server services are not in use | Remediation
    - name: 2.2.10 Ensure nis server services are not in use | Remediation
      systemd:
        name: ypserv
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not ypserv_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"

  

  # 2.2.11 Ensure print server services are not in use
  #
  # The Common Unix Print System (CUPS) provides the ability to print to both local and
  # network printers. A system running CUPS can also accept print jobs from remote
  # systems and print them to local printers. It also provides a web based remote
  # administration capability.
  - name: "2.2.11 Ensure print server services are not in use"
    block:
    # 2.2.11 Ensure print server services are not in use | Audit
    - name: 2.2.11 Ensure print server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q cups && echo installed || echo not_installed
      changed_when: false
      register: cups_status_check

    # 2.2.11 Ensure print server services are not in use | Audit
    - name: 2.2.11 Ensure print server services are not in use | Audit
      systemd:
        name: cups
      ignore_errors: yes
      changed_when: false
      register: cups_service_status_check
      when: cups_status_check.stdout == 'installed'

    # Define remediation status
    - set_fact:
        cups_remediation_status: "{{ true if (cups_status_check.stdout == 'not_installed' or (cups_service_status_check.status.ActiveState == 'inactive' and (cups_service_status_check.status.UnitFileState is not defined or cups_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      
    # 2.2.11 Ensure print server services are not in use | Audit
    - name: 2.2.11 Ensure print server services are not in use | Audit
      systemd:
        name: cups.socket
      ignore_errors: yes
      changed_when: false
      register: cups_socket_status_check
      when: cups_status_check.stdout == 'installed'

    # Append to remediation status
    - set_fact:
        cups_remediation_status: "{{ true if (cups_remediation_status and (cups_socket_status_check.status.ActiveState == 'inactive' and (cups_socket_status_check.status.UnitFileState is not defined or cups_socket_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: cups_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        cups_check:
          name: 2.2.11 Ensure print server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if cups_remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [cups_check] }}"
      changed_when: false

    # 2.2.11 Ensure print server services are not in use | Remediation
    - name: 2.2.11 Ensure print server services are not in use | Remediation
      systemd:
        name: cups
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not cups_check.remediation_status
    
    # 2.2.11 Ensure print server services are not in use | Remediation
    - name: 2.2.11 Ensure print server services are not in use | Remediation
      systemd:
        name: cups.socket
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not cups_check.remediation_status
    tags:
    - "server_level_1"
    when: "'server_level_1' in levels"



  # 2.2.12 Ensure rpcbind services are not in use
  #
  # The rpcbind utility maps RPC services to the ports on which they listen. RPC processes
  # notify rpcbind when they start, registering the ports they are listening on and the RPC
  # program numbers they expect to serve. The client system then contacts rpcbind on the
  # server with a particular RPC program number. The rpcbind.service redirects the client
  # to the proper port number so it can communicate with the requested service.
  # Portmapper is an RPC service, which always listens on tcp and udp 111, and is used to
  # map other RPC services (such as nfs, nlockmgr, quotad, mountd, etc.) to their
  # corresponding port number on the server. When a remote host makes an RPC call to
  # that server, it first consults with portmap to determine where the RPC server is listening.
  - name: "2.2.12 Ensure rpcbind services are not in use"
    block:
    # 2.2.12 Ensure rpcbind services are not in use | Audit
    - name: 2.2.12 Ensure rpcbind services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q rpcbind && echo installed || echo not_installed
      changed_when: false
      register: rpcbind_status_check

    # 2.2.12 Ensure rpcbind services are not in use | Audit
    - name: 2.2.12 Ensure rpcbind services are not in use | Audit
      systemd:
        name: rpcbind
      ignore_errors: yes
      changed_when: false
      register: rpcbind_service_status_check
      when: rpcbind_status_check.stdout == 'installed'

    # Define remediation status
    - set_fact:
        rpcbind_remediation_status: "{{ true if (rpcbind_status_check.stdout == 'not_installed' or (rpcbind_service_status_check.status.ActiveState == 'inactive' and (rpcbind_service_status_check.status.UnitFileState is not defined or rpcbind_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      
    # 2.2.12 Ensure rpcbind services are not in use | Audit
    - name: 2.2.12 Ensure rpcbind services are not in use | Audit
      systemd:
        name: rpcbind.socket
      ignore_errors: yes
      changed_when: false
      register: rpcbind_socket_status_check
      when: rpcbind_status_check.stdout == 'installed'

    # Append to remediation status
    - set_fact:
        rpcbind_remediation_status: "{{ true if (rpcbind_remediation_status and (rpcbind_socket_status_check.status.ActiveState == 'inactive' and (rpcbind_socket_status_check.status.UnitFileState is not defined or rpcbind_socket_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: rpcbind_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        rpcbind_check:
          name: 2.2.12 Ensure rpcbind services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if rpcbind_remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [rpcbind_check] }}"
      changed_when: false

    # 2.2.12 Ensure rpcbind services are not in use | Remediation
    - name: 2.2.12 Ensure rpcbind services are not in use | Remediation
      systemd:
        name: rpcbind
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not rpcbind_check.remediation_status
    
    # 2.2.12 Ensure rpcbind services are not in use | Remediation
    - name: 2.2.12 Ensure rpcbind services are not in use | Remediation
      systemd:
        name: rpcbind.socket
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not rpcbind_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.13 Ensure rsync services are not in use
  #
  # The rsyncd.service can be used to synchronize files between systems over network
  # links.
  - name: "2.2.13 Ensure rsync services are not in use"
    block:
    # 2.2.13 Ensure rsync services are not in use | Audit
    - name: 2.2.13 Ensure rsync services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q "rsync-daemon" && echo installed || echo not_installed
      changed_when: false
      register: rsyncd_status_check

    # 2.2.13 Ensure rsync services are not in use | Audit
    - name: 2.2.13 Ensure rsync services are not in use | Audit
      systemd:
        name: rsyncd
      ignore_errors: yes
      changed_when: false
      register: rsyncd_service_status_check
      when: rsyncd_status_check.stdout == 'installed'

    # Define remediation status
    - set_fact:
        rsyncd_remediation_status: "{{ true if (rsyncd_status_check.stdout == 'not_installed' or (rsyncd_service_status_check.status.ActiveState == 'inactive' and (rsyncd_service_status_check.status.UnitFileState is not defined or rsyncd_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      
    # 2.2.13 Ensure rsync services are not in use | Audit
    - name: 2.2.13 Ensure rsync services are not in use | Audit
      systemd:
        name: rsyncd.socket
      ignore_errors: yes
      changed_when: false
      register: rsyncd_socket_status_check
      when: rsyncd_status_check.stdout == 'installed'

    # Append to remediation status
    - set_fact:
        rsyncd_remediation_status: "{{ true if (rsyncd_remediation_status and (rsyncd_socket_status_check.status.ActiveState == 'inactive' and (rsyncd_socket_status_check.status.UnitFileState is not defined or rsyncd_socket_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: rsyncd_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        rsyncd_check:
          name: 2.2.13 Ensure rsync services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if rsyncd_remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [rsyncd_check] }}"
      changed_when: false

    # 2.2.13 Ensure rsync services are not in use | Remediation
    - name: 2.2.13 Ensure rsync services are not in use | Remediation
      systemd:
        name: rsyncd
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not rsyncd_check.remediation_status
    
    # 2.2.13 Ensure rsync services are not in use | Remediation
    - name: 2.2.13 Ensure rsync services are not in use | Remediation
      systemd:
        name: rsyncd.socket
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not rsyncd_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.14 Ensure snmp services are not in use
  #
  # Simple Network Management Protocol (SNMP) is a widely used protocol for monitoring
  # the health and welfare of network equipment, computer equipment and devices like
  # UPSs.
  # Net-SNMP is a suite of applications used to implement SNMPv1 (RFC 1157), SNMPv2
  # (RFCs 1901-1908), and SNMPv3 (RFCs 3411-3418) using both IPv4 and IPv6.
  # Support for SNMPv2 classic (a.k.a. "SNMPv2 historic" - RFCs 1441-1452) was dropped
  # with the 4.0 release of the UCD-snmp package.
  # The Simple Network Management Protocol (SNMP) server is used to listen for SNMP
  # commands from an SNMP management system, execute the commands or collect the
  # information and then send results back to the requesting system.
  - name: "2.2.14 Ensure snmp services are not in use"
    block:
    # 2.2.14 Ensure snmp services are not in use | Audit
    - name: 2.2.14 Ensure snmp services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q "net-snmp" && echo installed || echo not_installed
      changed_when: false
      register: snmpd_status_check

    # 2.2.14 Ensure snmp services are not in use | Audit
    - name: 2.2.14 Ensure snmp services are not in use | Audit
      systemd:
        name: snmpd
      ignore_errors: yes
      changed_when: false
      register: snmpd_service_status_check
      when: snmpd_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        snmpd_check:
          name: 2.2.14 Ensure snmp services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (snmpd_status_check.stdout == 'not_installed' or (snmpd_service_status_check.status.ActiveState == 'inactive' and (snmpd_service_status_check.status.UnitFileState is not defined or snmpd_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [snmpd_check] }}"
      changed_when: false

    # 2.2.14 Ensure snmp services are not in use | Remediation
    - name: 2.2.14 Ensure snmp services are not in use | Remediation
      systemd:
        name: snmpd
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not snmpd_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.15 Ensure telnet server services are not in use
  #
  # The telnet-server package contains the telnet daemon, which accepts connections
  # from users from other systems via the telnet protocol.
  - name: "2.2.15 Ensure telnet server services are not in use"
    block:
    # 2.2.15 Ensure telnet server services are not in use | Audit
    - name: 2.2.15 Ensure telnet server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q "telnet-server" && echo installed || echo not_installed
      changed_when: false
      register: telnet_server_status_check

    # 2.2.15 Ensure telnet server services are not in use | Audit
    - name: 2.2.15 Ensure telnet server services are not in use | Audit
      systemd:
        name: telnet.socket
      ignore_errors: yes
      changed_when: false
      register: telnet_socket_service_status_check
      when: telnet_server_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        telnet_server_check:
          name: 2.2.15 Ensure telnet server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (telnet_server_status_check.stdout == 'not_installed' or (telnet_socket_service_status_check.status.ActiveState == 'inactive' and (telnet_socket_service_status_check.status.UnitFileState is not defined or telnet_socket_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [telnet_server_check] }}"
      changed_when: false

    # 2.2.15 Ensure telnet server services are not in use | Remediation
    - name: 2.2.15 Ensure telnet server services are not in use | Remediation
      systemd:
        name: telnet.socket
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not telnet_server_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.16 Ensure tftp server services are not in use
  #
  # Trivial File Transfer Protocol (TFTP) is a simple protocol for exchanging files between
  # two TCP/IP machines. TFTP servers allow connections from a TFTP Client for sending
  # and receiving files.
  - name: "2.2.16 Ensure tftp server services are not in use"
    block:
    # 2.2.16 Ensure tftp server services are not in use | Audit
    - name: 2.2.16 Ensure tftp server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q "tftp-server" && echo installed || echo not_installed
      changed_when: false
      register: tftp_server_status_check

    # 2.2.16 Ensure tftp server services are not in use | Audit
    - name: 2.2.16 Ensure tftp server services are not in use | Audit
      systemd:
        name: tftp
      ignore_errors: yes
      changed_when: false
      register: tftp_server_service_status_check
      when: tftp_server_status_check.stdout == 'installed'

    # Define remediation status
    - set_fact:
        tftp_server_remediation_status: "{{ true if (tftp_server_status_check.stdout == 'not_installed' or (tftp_server_service_status_check.status.ActiveState == 'inactive' and (tftp_server_service_status_check.status.UnitFileState is not defined or tftp_server_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      
    # 2.2.16 Ensure tftp server services are not in use | Audit
    - name: 2.2.16 Ensure tftp server services are not in use | Audit
      systemd:
        name: tftp.socket
      ignore_errors: yes
      changed_when: false
      register: tftp_socket_status_check
      when: tftp_server_status_check.stdout == 'installed'

    # Append to remediation status
    - set_fact:
        tftp_server_remediation_status: "{{ true if (tftp_server_remediation_status and (tftp_socket_status_check.status.ActiveState == 'inactive' and (tftp_socket_status_check.status.UnitFileState is not defined or tftp_socket_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: tftp_server_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        tftp_server_check:
          name: 2.2.16 Ensure tftp server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if tftp_server_remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [tftp_server_check] }}"
      changed_when: false

    # 2.2.16 Ensure tftp server services are not in use | Remediation
    - name: 2.2.16 Ensure tftp server services are not in use | Remediation
      systemd:
        name: tftp
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not tftp_server_check.remediation_status
    
    # 2.2.16 Ensure tftp server services are not in use | Remediation
    - name: 2.2.16 Ensure tftp server services are not in use | Remediation
      systemd:
        name: tftp.socket
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not tftp_server_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.17 Ensure web proxy server services are not in use
  #
  # Squid is a standard proxy server used in many distributions and environments.
  - name: "2.2.17 Ensure web proxy server services are not in use"
    block:
    # 2.2.17 Ensure web proxy server services are not in use | Audit
    - name: 2.2.17 Ensure web proxy server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q squid && echo installed || echo not_installed
      changed_when: false
      register: squid_server_status_check

    # 2.2.17 Ensure web proxy server services are not in use | Audit
    - name: 2.2.17 Ensure web proxy server services are not in use | Audit
      systemd:
        name: squid
      ignore_errors: yes
      changed_when: false
      register: squid_service_status_check
      when: squid_server_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        squid_server_check:
          name: 2.2.17 Ensure web proxy server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (squid_server_status_check.stdout == 'not_installed' or (squid_service_status_check.status.ActiveState == 'inactive' and (squid_service_status_check.status.UnitFileState is not defined or squid_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [squid_server_check] }}"
      changed_when: false

    # 2.2.17 Ensure web proxy server services are not in use | Remediation
    - name: 2.2.17 Ensure web proxy server services are not in use | Remediation
      systemd:
        name: squid
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not squid_server_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.18 Ensure web server services are not in use
  #
  # Web servers provide the ability to host web site content.
  - name: "2.2.18 Ensure web server services are not in use"
    block:
    # 2.2.18 Ensure web server services are not in use | Audit
    - name: 2.2.18 Ensure web server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q httpd && echo installed || echo not_installed
      changed_when: false
      register: httpd_status_check

    # 2.2.18 Ensure web server services are not in use | Audit
    - name: 2.2.18 Ensure web server services are not in use | Audit
      systemd:
        name: httpd
      ignore_errors: yes
      changed_when: false
      register: httpd_service_status_check
      when: httpd_status_check.stdout == 'installed'

    # Define remediation status
    - set_fact:
        remediation_status: "{{ true if (httpd_status_check.stdout == 'not_installed' or (httpd_service_status_check.status.ActiveState == 'inactive' and (httpd_service_status_check.status.UnitFileState is not defined or httpd_service_status_check.status.UnitFileState != 'enabled'))) else false }}"

    # 2.2.18 Ensure web server services are not in use | Audit
    - name: 2.2.18 Ensure web server services are not in use | Audit
      systemd:
        name: httpd.socket
      ignore_errors: yes
      changed_when: false
      register: httpd_socket_status_check
      when: httpd_status_check.stdout == 'installed'

    # Update remediation status
    - set_fact:
        remediation_status: "{{ true if (remediation_status and (httpd_socket_status_check.status.ActiveState == 'inactive' and (httpd_socket_status_check.status.UnitFileState is not defined or httpd_socket_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: httpd_status_check.stdout == 'installed'

    # 2.2.18 Ensure web server services are not in use | Audit
    - name: 2.2.18 Ensure web server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q nginx && echo installed || echo not_installed
      changed_when: false
      register: nginx_status_check

    # 2.2.18 Ensure web server services are not in use | Audit
    - name: 2.2.18 Ensure web server services are not in use | Audit
      systemd:
        name: nginx
      ignore_errors: yes
      changed_when: false
      register: nginx_service_status_check
      when: nginx_status_check.stdout == 'installed'

    # Update remediation status
    - set_fact:
        remediation_status: "{{ true if ((remediation_status or nginx_status_check.stdout == 'not_installed') and (nginx_service_status_check.status.ActiveState == 'inactive' and (nginx_service_status_check.status.UnitFileState is not defined or nginx_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false
      when: nginx_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        web_server_check:
          name: 2.2.18 Ensure web server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if remediation_status else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [web_server_check] }}"
      changed_when: false

    # 2.2.18 Ensure web server services are not in use | Remediation
    - name: 2.2.18 Ensure web server services are not in use | Remediation
      systemd:
        name: httpd
        state: stopped
        enabled: false
        masked: true
        force: true
      when: httpd_status_check.stdout == 'installed' and not audit_only and not web_server_check.remediation_status

    # 2.2.18 Ensure web server services are not in use | Remediation
    - name: 2.2.18 Ensure web server services are not in use | Remediation
      systemd:
        name: httpd.socket
        state: stopped
        enabled: false
        masked: true
        force: true
      when: httpd_status_check.stdout == 'installed' and not audit_only and not web_server_check.remediation_status

    # 2.2.18 Ensure web server services are not in use | Remediation
    - name: 2.2.18 Ensure web server services are not in use | Remediation
      systemd:
        name: nginx
        state: stopped
        enabled: false
        masked: true
        force: true
      when: nginx_status_check.stdout == 'installed' and not audit_only and not web_server_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.19 Ensure xinetd services are not in use
  #
  # The X Window System provides a Graphical User Interface (GUI) where users can have
  # multiple windows in which to run programs and various add on. The X Windows system
  # is typically used on workstations where users login, but not on servers where users
  # typically do not login.
  - name: "2.2.19 Ensure xinetd services are not in use"
    block:
    # 2.2.19 Ensure xinetd services are not in use | Audit
    - name: 2.2.19 Ensure xinetd services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q xinetd && echo installed || echo not_installed
      changed_when: false
      register: xinetd_server_status_check

    # 2.2.19 Ensure xinetd services are not in use | Audit
    - name: 2.2.19 Ensure xinetd services are not in use | Audit
      systemd:
        name: xinetd
      ignore_errors: yes
      changed_when: false
      register: xinetd_service_status_check
      when: xinetd_server_status_check.stdout == 'installed'

    # Extract audit result
    - set_fact:
        xinetd_server_check:
          name: 2.2.19 Ensure xinetd services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if (xinetd_server_status_check.stdout == 'not_installed' or (xinetd_service_status_check.status.ActiveState == 'inactive' and (xinetd_service_status_check.status.UnitFileState is not defined or xinetd_service_status_check.status.UnitFileState != 'enabled'))) else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [xinetd_server_check] }}"
      changed_when: false

    # 2.2.19 Ensure xinetd services are not in use | Remediation
    - name: 2.2.19 Ensure xinetd services are not in use | Remediation
      systemd:
        name: xinetd
        state: stopped
        enabled: false
        masked: true
        force: true
      when: not audit_only and not xinetd_server_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.20 Ensure X window server services are not in use
  #
  # The X Window System provides a Graphical User Interface (GUI) where users can have
  # multiple windows in which to run programs and various add on. The X Windows system
  # is typically used on workstations where users login, but not on servers where users
  # typically do not login.
  - name: "2.2.20 Ensure X window server services are not in use"
    block:
    # 2.2.20 Ensure X window server services are not in use | Audit
    - name: 2.2.20 Ensure X window server services are not in use | Audit
      shell:
        cmd: rpm -qa | grep -q "xorg-x11-server-common" && echo installed || echo not_installed
      changed_when: false
      register: xorg_status_check

    # Extract audit result
    - set_fact:
        xorg_server_check:
          name: 2.2.20 Ensure X window server services are not in use
          scored: true
          automated: true
          remediation_status: "{{ true if xorg_status_check.stdout == 'not_installed' else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [xorg_server_check] }}"
      changed_when: false

    # 2.2.20 Ensure X window server services are not in use | Remediation
    - name: 2.2.20 Ensure X window server services are not in use | Remediation
      package:
        name: xorg-x11-server-common
        state: absent
      when: not audit_only and not xorg_server_check.remediation_status
    tags:
    - "server_level_2"
    when: "'server_level_2' in levels"



  # 2.2.21 Ensure mail transfer agents are configured for local-only mode
  #
  # Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for
  # incoming mail and transfer the messages to the appropriate user or mail server. If the
  # system is not intended to be a mail server, it is recommended that the MTA be
  # configured to only process local mail.
  - name: "2.2.21 Ensure mail transfer agents are configured for local-only mode"
    block:
    # 2.2.21 Ensure mail transfer agents are configured for local-only mode | Audit
    - name: 2.2.21 Ensure mail transfer agents are configured for local-only mode | Audit
      shell:
        cmd: |
          ss -plntu | grep -P -- ':25\b' | grep -Pv -- '\h+(127\.0\.0\.1|\[?::1\]?):25\b' || \
          ss -plntu | grep -P -- ':465\b' | grep -Pv -- '\h+(127\.0\.0\.1|\[?::1\]?):465\b' || \
          ss -plntu | grep -P -- ':587\b' | grep -Pv -- '\h+(127\.0\.0\.1|\[?::1\]?):587\b' | wc -l || echo "1"
      changed_when: false
      register: mail_transfer_agents_status_check

    # Extract audit result
    - set_fact:
        mail_transfer_agents_check:
          name: 2.2.21 Ensure mail transfer agents are configured for local-only mode
          scored: true
          automated: true
          remediation_status: "{{ true if (mail_transfer_agents_status_check | int ) == 0 else false }}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [mail_transfer_agents_check] }}"
      changed_when: false

    # 2.2.21 Ensure mail transfer agents are configured for local-only mode | Remediation
    - name: 2.2.21 Ensure mail transfer agents are configured for local-only mode | Remediation
      ansible.builtin.lineinfile:
        path: /etc/postfix/main.cf
        regexp: '^\s{0,}inet_interfaces\s{0,}=\s{0,}loopback-only'
        line: "inet_interfaces = loopback-only"
        mode: "0644"
        owner: root
        group: root
        create: true
      when: not audit_only and not mail_transfer_agents_check.remediation_status
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"



  # 2.2.22 Ensure only approved services are listening on a network
  #
  # A network port is identified by its number, the associated IP address, and the type of the
  # communication protocol such as TCP or UDP.
  # A listening port is a network port on which an application or process listens on, acting as
  # a communication endpoint.
  # Each listening port can be open or closed (filtered) using a firewall. In general terms, an
  # open port is a network port that accepts incoming packets from remote locations.
  - name: "2.2.22 Ensure only approved services are listening on a network"
    block:
    # 2.2.22 Ensure only approved services are listening on a network | Audit
    - name: 2.2.22 Ensure only approved services are listening on a network | Audit
      shell:
        cmd: ss -plntu | awk '{if (NR>1){split($NF,a,"\"");print "Service " a[2] " listening on " $5 " " $1}}'
      changed_when: false
      register: listening_ports_status_check

    # Extract audit result
    - set_fact:
        listening_ports_check:
          name: 2.2.22 Ensure only approved services are listening on a network
          scored: false
          automated: false
          remediation: "Consider to verify the list of services bellow: \n {% for item in listening_ports_status_check.stdout_lines %}{{ item + '\n'}}{% endfor %}"
      changed_when: false

    # Appending audit result
    - set_fact:
        audit_result: "{{ (audit_result | default([])) + [listening_ports_check] }}"
      changed_when: false

    # 2.2.22 Ensure only approved services are listening on a network | Remediation
    - name: 2.2.22 Ensure only approved services are listening on a network | Remediation
      debug:
        var: listening_ports_check.remediation
    tags:
    - "server_level_1"
    - "workstation_level_1"
    when: "'server_level_1' in levels or 'workstation_level_1' in levels"

